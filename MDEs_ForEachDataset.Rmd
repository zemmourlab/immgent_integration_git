---
title: "MDEs_ForEachDataset"
output: html_document
date: "2025-05-21"
editor_options: 
  chunk_output_type: console
---

**Start interactive session on Midway3**
```{bash}
ssh -Y zemmour@midway3.rcc.uchicago.edu
sinfo -s
screen -S david
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=jfkfloor2 --qos=jfkfloor2 --nodes=1 
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=zemmour-hm --qos=zemmour --nodes=1 
sinteractive --time=12:00:00 --account=pi-zemmour --partition=beagle3-bigmem --nodes=1 --mem=128GB
sinteractive --time=12:00:00 --account=pi-zemmour --partition=caslake --nodes=1 --mem=96GB
sinteractive --time=3:00:00 --account=pi-zemmour --partition=gpu --gres=gpu:1 --mem=152GB
cd $LABHOME

module load python/anaconda-2022.05 
module load hdf5/1.12.0 #for BPCells but also others
module load openblas/0.3.13

#sinteractive --time=1:00:00 -p gpu --gres=gpu:1 --account=pi-zemmour 

#source activate /project/jfkfloor2/zemmourlab/david/envs/scvi
source activate /project/zemmour/david/envs/scvi_20240315
module load openblas/0.3.13 #load again or error

cd /project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/
#cd ~/google_drive/ImmgenT/analysis/data_integration/IGT1_56/Treg

#srun --pty --jobid 21908677 -w midway3-0291 /bin/bash

R
#options(max.print=1000)
#options(Seurat.object.assay.version = 'v5')
```

**Initialize in R: load libraries and custom functions**

```{r}
options(max.print=1000)
# setwd("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_96")
source("/project/jfkfloor2/zemmourlab/david/immgent/immgent_integration_git/custom_functions_david.R")

libs = c("fgsea","fastTopics", "flashier", "Matrix", "Seurat","BPCells", "ggplot2", "dplyr", "reshape2", "ggrastr", "RColorBrewer", "pals", "scales", "pheatmap", "rafalib", "limma") 
#libs = c("matrixStats", "gplots","ggplot2", "reshape2", "scales", "gridExtra", "dplyr", "RColorBrewer", "grid", "Rtsne", "limma",   "RColorBrewer", "pheatmap", "Seurat",  "ggrastr", "ggbeeswarm") #pwr, preprocessCore, "readxl", vegan", "genefilter" "scde" "cellrangerRkit", "Rsamtools", "GenomicRanges", "GenomicAlignments", "VGAM", "WGCNA",rafalib, ‘UsingR’,MAST "ggrastr",
sapply(libs, function(x) suppressMessages(suppressWarnings(library(x, character.only = TRUE, quietly = T, warn.conflicts  = F))))


#Gradients
library(RColorBrewer)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdYlBu"))(100))
# ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = rev(rainbow(10, end = 4/6))
library(viridis)
ColorRamp = rev(viridis(100))
ColorRamp = rev(cividis(100))
ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = colorRampPalette(c('white','red'))(20)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdBu"))(100))
# ColorRamp = colorRampPalette(c('Red'))(20)
#image(1:100, 1, as.matrix(1:100), col = ColorRamp, main = "Color Palette", xaxt = 'n', yaxt = 'n', xlab = "", ylab = "")

#mycol = c("black","blue","red","darkgreen", "orange","purple", "cyan", "greenyellow",    "salmon", "magenta","pink", "tan", "brown") # c("magenta", "red",  "darkgreen", "cyan", "blue", "blue", "blue", "black", "blue", "blue", "blue", "blue", "orange")

#Large Color palette
library("pals")
n = 70
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
mypal1 = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
mypal1 = mypal1[-4]
mypal = c(glasbey(), polychrome(), mypal1)
names(mypal) = NULL
#pal.bands(mypal, main="Colormap suggestions")
mypal_organ = setNames(mypal, unique(so$organ_simplified))
mypal_organ = mypal_organ[!is.na(names(mypal_organ))]
mypal_level1 = setNames(mypal, unique(so$annotation_level1))
mypal_level1 = mypal_level1[!is.na(names(mypal_level1))]
mypal_level2 = setNames(mypal, unique(so_orig$annotation_level2))
mypal_level2 = mypal_level2[!is.na(names(mypal_level2))]
mypal_level2["CD4_cl18"] = "blue"
mypal_igt = setNames(mypal, unique(so$IGT))
mypal_igt = mypal_igt[!is.na(names(mypal_igt))]


#parade = function(n) { return(Seurat::DiscretePalette(n, palette = "parade", shuffle = F)) }
```

**Load dataset**

```{r}

so_orig = readRDS("/project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/igt1_96_withtotalvi20250513_clean.Rds") 


```


```{r}

library(gridExtra)

so = so_orig[,so_orig$annotation_level1 == "CD4"]

so = list()
so[["CD4"]] = so_orig[,so_orig$annotation_level1 == "CD4"]
so[["CD8"]] =  so_orig[,so_orig$annotation_level1 == "CD8"]
so[["Treg"]] =  so_orig[,so_orig$annotation_level1 == "Treg"]
so[["gdT"]] = so_orig[,so_orig$annotation_level1 == "gdT"]
so[["CD8aa"]] = so_orig[,so_orig$annotation_level1 == "CD8aa"]
so[["nonconv"]] = so_orig[,so_orig$annotation_level1 == "nonconv"]
so[["DN"]] = so_orig[,so_orig$annotation_level1 == "DN"]
so[["DP"]] = so_orig[,so_orig$annotation_level1 == "DP"]


IGT = "IGT1"
level1 = c("CD4", "CD8", "Treg", "gdT", "CD8aa", "nonconv", "DN", "DP")

for (i in unique(so_orig$IGT)) {
    samples = so_orig@meta.data %>% filter(IGT == i) %>% pull(sample_code) %>% unique()
    for (s in samples) {
        print(s)
        ensure_directory(sprintf("MDE_perEachSample/%s/", i))
        pdf(sprintf("MDE_perEachSample/%s/%s_MDEs2.pdf", i, s), width = 20, height = 20, useDingbats = T)
        ps = list()
        for (l in level1) {
            # print(l)
            p = MyDimPlotHighlight(seurat_object = so[[l]], umap_to_plot = "mde_incremental", cells_to_highlight = colnames(so[[l]])[which(so[[l]]$sample_code == s)], highlight_column_name = "annotation_level2", pixels = c(512, 512), mycols = mypal_level2, title = sprintf("%s in %s", l, s), highlight_size = 1, highlight_alpha = 1, print_plot1 = T, print_plot2 = T, labelclusters = T)
            ps[[l]] = p$plot2
            ps[[l]] = p$plot3 #to get plot with labels
        }
        grid.arrange(grobs = ps, ncol = 3, nrow = 3)
        dev.off()
    }
}

MyDimPlotHighlight <- function(seurat_object = so, 
                               umap_to_plot = "mde_totalvi_20241201_gdT_rmIGTsample", 
                               cells_to_highlight = names(which(so$nonconv_tcr_recog == T)), 
                               highlight_column_name = "nonconv_tcr_recog", 
                               title = "", 
                               labelclusters = T, 
                               pixels = c(512, 512), 
                               highlight_size = 1, 
                               highlight_alpha = 1,
                               xlim = NULL,
                               ylim = NULL,
                               mycols = mypal, 
                               print_plot1 = TRUE, 
                               print_plot2 = TRUE) {
    
    require(scattermore)
    require(ggplot2)
    
    # missing_names = setdiff(unique(seurat_object@meta.data[,highlight_column_name]), names(mycols))
    # new_colors = mycols[which(is.na(names(mycols)))[1:length(missing_names)]]
    # names(new_colors) = missing_names
    # color_mapping = c(mycols[!is.na(names(mycols))], new_colors)
    # # color_mapping = setNames(mycols, unique(so@meta.data[,highlight_column_name]))
    
    missing_names = setdiff(unique(seurat_object@meta.data[[highlight_column_name]]), names(mycols))
    # missing_names = setdiff(levels(seurat_object@meta.data[[highlight_column_name]]), names(mycols))
    
    # new_colors <- setNames(mycols[seq_len(length(missing_names))], missing_names)
    # color_mapping <- c(mycols[!is.na(names(mycols))], new_colors)
    
    if (length(missing_names) > 0) {
        # Assign new colors to missing categories
        if (any(is.na(names(mycols)))) {
            new_colors = mycols[which(is.na(names(mycols)))][1:length(missing_names)]
        } else {
            new_colors = mycols[1:length(missing_names)]
        }
        names(new_colors) <- missing_names
        color_mapping <- c(mycols[!is.na(names(mycols))], new_colors)
    } else {
        color_mapping = mycols
    }
    
    # UMAP embeddings
    dim1 <- seurat_object[[umap_to_plot]]@cell.embeddings[, 1]
    dim2 <- seurat_object[[umap_to_plot]]@cell.embeddings[, 2]
    tmp <- data.frame(seurat_object@meta.data, dim1 = dim1, dim2 = dim2)
    
    # Subset for highlighted cells
    tmp2 <- tmp[cells_to_highlight, ]
    
    # Filter unique cluster labels present in cells_to_highlight
    highlight_values <- unique(tmp2[[highlight_column_name]])
    
    # Background plot
    bkrg <- ggplot(tmp) + 
        geom_scattermore(aes(dim1, dim2), color = "grey50", pointsize = 0.5, alpha = 0.5, pixels = pixels)
    
    # Highlighted points
    p2 <- geom_point(data = tmp2, 
                     aes(dim1, dim2, color = !!sym(highlight_column_name)), 
                     size = highlight_size, 
                     alpha = highlight_alpha)
    
    # Plots with consistent colors
    plot1 <- bkrg + p2 + 
        scale_color_manual(values = color_mapping) + 
        scale_x_continuous(limits = xlim) +
        scale_y_continuous(limits = ylim) +
        ggtitle(title) + 
        theme_minimal()
    
    plot2 <- bkrg + p2 + 
        scale_color_manual(values = color_mapping) + 
        scale_x_continuous(limits = xlim) +
        scale_y_continuous(limits = ylim) +
        theme_void() + NoLegend()
    
    # Add cluster labels dynamically for only the present values
    if (labelclusters) {
        tmp_labels <- tmp2 %>%
            filter(!!sym(highlight_column_name) %in% highlight_values) %>%
            group_by(!!sym(highlight_column_name)) %>%
            summarise(dim1 = median(dim1), dim2 = median(dim2))
        
        plot3 <- plot2 + 
            geom_text(data = tmp_labels, 
                      aes(x = dim1, y = dim2, label = !!sym(highlight_column_name), 
                          color = !!sym(highlight_column_name)),
                      size = 4, show.legend = FALSE) +
            scale_color_manual(values = color_mapping) +
            scale_x_continuous(limits = xlim) +
            scale_y_continuous(limits = ylim) +
            ggtitle(title)
    } else {
        plot3 <- NULL
    }
    
    # Print plots
    # if (print_plot1) print(plot1)
    # if (print_plot2) print(plot2)
    # if (labelclusters && !is.null(plot3)) print(plot3)
    # # Prevent implicit return
    # invisible(NULL)
    
    plot1 = if (print_plot1) plot1 else NULL
    plot2 = if (print_plot2) plot2 else NULL
    plot3 = if (labelclusters && !is.null(plot3)) plot3 else NULL

    plot_list = list(plot1 = plot1, plot2 = plot2, plot3 = plot3)
    return(plot_list)

   
}




```














