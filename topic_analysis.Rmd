---
title: "topic_analysis"
output: html_document
date: "2024-04-30"
---

**Start interactive session on Midway3**
```{bash}
ssh -Y zemmour@midway3.rcc.uchicago.edu
sinfo -s
screen -S david
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=jfkfloor2 --qos=jfkfloor2 --nodes=1 
sinteractive --time=12:00:00 --account=pi-zemmour --partition=caslake --nodes=1 --mem=96GB
sinteractive --time=3:00:00 --account=pi-zemmour --partition=gpu --gres=gpu:1 --mem=152GB
cd $LABHOME

module load python/anaconda-2022.05 
module load hdf5/1.12.0 #for BPCells but also others
module load openblas/0.3.13

#sinteractive --time=1:00:00 -p gpu --gres=gpu:1 --account=pi-zemmour 

#source activate /project/jfkfloor2/zemmourlab/david/envs/scvi
source activate /project/zemmour/david/envs/scvi_20240315
module load openblas/0.3.13 #load again or error

cd /project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Treg
#cd ~/google_drive/ImmgenT/analysis/data_integration/IGT1_56/Treg

#srun --pty --jobid 21908677 -w midway3-0291 /bin/bash

#R
#options(max.print=1000)
#options(Seurat.object.assay.version = 'v5')
```

**Initialize in R: load libraries and custom functions**

```{r}
options(max.print=1000)
setwd("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Treg")
source("/project/jfkfloor2/zemmourlab/david/immgent/immgent_integration_git/custom_functions_david.R")

libs = c("fastTopics", "flashier", "Matrix", "Seurat","BPCells", "ggplot2", "dplyr", "reshape2", "ggrastr", "RColorBrewer", "pals", "scales", "pheatmap") 
#libs = c("matrixStats", "gplots","ggplot2", "reshape2", "scales", "gridExtra", "dplyr", "RColorBrewer", "grid", "Rtsne", "limma",   "RColorBrewer", "pheatmap", "Seurat",  "ggrastr", "ggbeeswarm") #pwr, preprocessCore, "readxl", vegan", "genefilter" "scde" "cellrangerRkit", "Rsamtools", "GenomicRanges", "GenomicAlignments", "VGAM", "WGCNA",rafalib, â€˜UsingRâ€™,MAST "ggrastr",
sapply(libs, function(x) suppressMessages(suppressWarnings(library(x, character.only = TRUE, quietly = T, warn.conflicts  = F))))


#Gradients
library(RColorBrewer)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdYlBu"))(100))
ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = rev(rainbow(10, end = 4/6))
library(viridis)
ColorRamp = rev(viridis(100))
ColorRamp = rev(cividis(100))
#image(1:100, 1, as.matrix(1:100), col = ColorRamp, main = "Color Palette", xaxt = 'n', yaxt = 'n', xlab = "", ylab = "")

#mycol = c("black","blue","red","darkgreen", "orange","purple", "cyan", "greenyellow",    "salmon", "magenta","pink", "tan", "brown") # c("magenta", "red",  "darkgreen", "cyan", "blue", "blue", "blue", "black", "blue", "blue", "blue", "blue", "orange")

#Large Color palette
library("pals")
n = 70
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
mypal1 = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
mypal1 = mypal1[-4]
mypal = c(glasbey(), polychrome(), mypal1)
names(mypal) = NULL
#pal.bands(mypal, main="Colormap suggestions")

#parade = function(n) { return(Seurat::DiscretePalette(n, palette = "parade", shuffle = F)) }

ensure_directory <- function(path) {
  if (!dir.exists(path)) {
    dir.create(path, recursive = TRUE)
    message(paste("Directory created:", path))
  } else {
    message(paste("Directory already exists:", path))
  }
}
```

**Documentation**
https://stephenslab.github.io/fastTopics/articles/relationship.html:
The â€˜fastTopicsâ€™ approach aims to combine the advantages of Poisson NMF and topic modeling.
The Poisson NMF is easier to fit because it doesnâ€™t have the additional constraints (rows of L and columns of F sum to 1, i.e. probabilities).
On ther other hand, the parameters of the topic model are typically more useful for for understanding data; for example, the ð‘™âˆ—ð‘–ð‘˜
â€™s are topic proportions, which can be used to compare samples (documents), among other things.
So we provide a function to fit the Poisson NMF model (fit_poisson_nmf), and another function to obtain the topic model fit (poisson2multinom).

X = LF (poisson)
X: data matrix cells x genes
L: loadings: cells by k topics 
F: factors/topics: genes x k topics 

https://stephenslab.github.io/fastTopics/articles/topics_vs_clusters.html:
In general, a clustering will align closely with the topic modeling whenever the samples can be largely explained by a single topic or gene program.
X = FL (poisson) to model the data, easier to interpret: UMAP on L to cluster the cells based on topic proportions --> how much does it reproduce the original structure? Can we createa measure of that?
Differential expression of topics in cell clusters?


**Load data in R**
```{r}
#IGT1-56 subsets
prefix = "totalvi_igt1_56_20240306_allgenes"
to_subset = "Treg"
so = readRDS(file = sprintf("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/%s/bpcells/totalvi_igt1_56_allgenes_%s_20240306_counts/totalvi_igt1_56_allgenes_%s_20240306_BPCells_so.Rds", to_subset, to_subset, to_subset))
# so = readRDS(file = sprintf("~/google_drive/ImmgenT/analysis/data_integration/IGT1_56/%s/bpcells/totalvi_igt1_56_allgenes_%s_20240306_counts/totalvi_igt1_56_allgenes_%s_20240306_BPCells_so.Rds", to_subset, to_subset, to_subset))
```

update the metadata in seurat object
```{r}
m = read.table("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Sample_metadata_david_20240324_v3.csv",header = T, sep = ",")

m$sample_id = paste(m$immgent_IGT_10xlane_id, m$hashtag_number, sep = "_")
so$sample_id = paste(so$IGT, so$hashtag_number, sep = "_")

someta = so@meta.data
someta = someta[, !(colnames(someta) %in% colnames(m) & !(colnames(someta) %in% c("sample_id", "hashtag_number")))]
m2 = merge(someta, m, by  = "sample_id", all.x = T)
m2$sample_id[which(is.na(m2$exp_number))]
m2$is_spleen_standard[which(is.na(m2$exp_number))] #missing metadata about spleen standards!!
m2$colnames[which(is.na(m2$exp_number))]

all(m2$colnames %in% rownames(so@meta.data))
rownames(m2) = m2$colnames
m2 = m2[rownames(so@meta.data),]
all(m2$colnames %in% rownames(so@meta.data))

so@meta.data = m2

#Adjust colnames(so) that was modified when merged
message("check colnames to be IGT.BARCODE")
pattern = "^IGT\\d{1,2}\\.[A-Z]{16}$"
matches = grepl(pattern, so$colnames)
all(matches)
#and adjust colnames if needed:
unique(so$IGT[which(matches == F)])
#Adjust colnames(so) 
#pattern = "(IGT\\S*)_(\\d+)"
so$colnames = colnames(so)
sample(colnames(so), 100)
pattern = "(\\S*)_(\\d+)"
so$colnames = gsub(pattern, "\\1", so$colnames) #remove the _1 or other number at the end
sample(so$colnames, 100)
unique(so$IGT[!grepl("^IGT", so$colnames)])
so$colnames[!grepl("^IGT", so$colnames)] = paste(so$IGT[!grepl("^IGT", so$colnames)], so$colnames[!grepl("^IGT", so$colnames)], sep = ".")
sample(so$colnames, 10)
any(duplicated(so$colnames))
#recheck
pattern = "^IGT\\d{1,2}\\.[A-Z]{16}$"
matches = grepl(pattern, so$colnames)
all(matches)
#so@meta.data[which(matches == F),]
if(all(matches)) {colnames(so) = so$colnames}
all(grepl(pattern, colnames(so)))

#add sample_id: IGT.HT
so$sample_id_david = paste(so$IGT, so$hashtag_number.x, sep = ".")

#order IGT
unique(so$IGT)
extract_numeric = function(x) {
  as.numeric(gsub("\\D", "", x))
}
ordered_vector = unique(so$IGT)[order(extract_numeric(unique(so$IGT)))] %>% as.character()
so$IGT = factor(so$IGT, levels = ordered_vector)

#annotate spleen control samples
so$organ[is.na(so$organ)] = "spleen"
so$condition_broad[is.na(so$condition_broad)] = "healthy"

#organ_simplified
so$organ_simplified = so$organ
so$organ_simplified[grep(pattern = "lymph node", so$organ)] = "LN"
so$organ_simplified[grep(pattern = "skin", so$organ)] = "skin"
so$organ_simplified[grep(pattern = "colon", so$organ)] = "colon"
so$organ_simplified[grep(pattern = "duoden|ileal|ileum|jejun|small intestine", so$organ)] = "small intestine"
#table(so$organ, so$organ_simplified)

#add is_spleen_healthy (spleen control)
so$is_spleen_healthy = F
so$is_spleen_healthy[so$organ == "spleen" & so$condition_broad == "healthy"] = T
so$is_spleen_healthy_igt = so$is_spleen_healthy
so$is_spleen_healthy_igt[so$is_spleen_healthy == T] = as.character(so$IGT[so$is_spleen_healthy == T])
#table(so$is_spleen_healthy_igt, so$IGT)

```


**Fit the topic model**
The fit_topic_model interface is intended to hide the details of model fitting, and it should work well for many data sets. Larger or more complex data sets my require some fine-tuning of the model fitting. See Part 2 for more on this.
With the default settings, the model fitting is accomplished in four steps: 
(1) initialize the Poisson NMF model fit (â€˜init_poisson_nmfâ€™); 
(2) perform the main model fitting step by running 100 EM updates using â€˜fit_poisson_nmfâ€™; 
(3) refine the fit by running 100 extrapolated SCD updates, again using â€˜fit_poisson_nmfâ€™; and 
(4) recover the multinomial topic model by calling â€˜poisson2multinomâ€™.

For larger data sets, more than 200 updates may be needed to qobtain a good fit.

```{r}
prefix_topic = "fasttopics_K6_20240520"
prefix_topic = "fasttopics_K10_20240520"
prefix_topic = "fasttopics_K30_20240520"
```

--> fasttopics_K6_20240520_fit.RDS
--> fasttopics_K10_20240520_fit.RDS
--> fasttopics_K30_20240520_fit.RDS
--> fasttopics_K6_20240521_fit.Rds

```{r}
genes_to_keep = rowSums(so[["RNA"]]$counts) >0
length(which(genes_to_keep))

counts = t(as(so[["RNA"]]$counts[genes_to_keep,], Class = "dgCMatrix") )

fit = fit_topic_model(counts,k = 6, control.init = list(nc = 24), control.main = list(nc = 24),control.refine = list(nc = 24))
fit = fit_topic_model(counts,k = 10, control.init = list(nc = 24), control.main = list(nc = 24),control.refine = list(nc = 24))
fit = fit_topic_model(counts,k = 30, control.init = list(nc = 24), control.main = list(nc = 24),control.refine = list(nc = 24))
dim(fit$L)
dim(fit$F)
pdf(sprintf("%s_convergence.pdf", prefix_topic), 5,5, useDingbats = F)
plot_progress(fit,x = "iter",add.point.every = 10,colors = "black") #+ theme_cowplot(font_size = 10)
dev.off()

#saveRDS(fit, file = sprintf("%s_fit.Rds", prefix_topic))
fit = readRDS(sprintf("%s_fit.Rds", prefix_topic))

SubsetFit = function(fit, cell.names = names(which(so$is_spleen_healthy == T))) {
    fit$L = fit$L[cell.names,]
    fit$s = fit$s[cell.names]
    return(fit)
}

```

Plot L in each single cells
```{r}
topic_colors = mypal[1:ncol(fit$F)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")

pdf(sprintf("%s_structureplot.pdf", prefix_topic), 20,8, useDingbats = F)
structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$organ_simplified)
structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy)
#structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy_igt)
fit_spleenctrl = SubsetFit(fit, names(which(so$is_spleen_healthy == T)))
structure_plot(fit_spleenctrl,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
dev.off()


pdf(sprintf("%s_UMAP.pdf", prefix_topic), 9,8, useDingbats = F)
for (k in 1:ncol(fit$L) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),1], dim2 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),2], size = fit$L[,k]) 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()


##########If needed: structure_plot equivalent
#Plot modules in single cell UMAP_1D
hc = hclust(dist(t(module_scores_percentile2)))
ord_modules = colnames(module_scores_percentile2)[hc$order]

#pca = prcomp(module_scores_percentile2, scale. = TRUE)
#pca_1 = pca$x[, 1]
#ordered_df = as.data.frame(module_scores_percentile2[order(pca_1),])
ordered_df = as.data.frame(module_scores_percentile2[ord_cells,ord_modules])
ordered_df$cell_id = factor(rownames(ordered_df), ordered = T)
melted_df = melt(ordered_df)
melted_df$variable = factor(melted_df$variable, levels = ord_modules, ordered = T)
melted_df = melted_df %>% arrange(cell_id)

pdf("modules_singlecell_barplot.pdf", 20,10, useDingbats = F)
p = ggplot(melted_df, aes(x = cell_id, y = value, fill = variable)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = mypal)+
    labs(x = "Cells", y = "Score", fill = "Module") +
    theme_minimal() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank()
    )
print(p)
dev.off()


```

Differentially expressed genes in topics
â€˜fastTopicsâ€™ extends the standard DE analysis to allow for partial membership to multiple groups (the methods are described here). 

lfc.stat = "vsnull: compare against the probability under the null model
lfc.stat = k: compare against a chosen topic, k
lfc.stat = "le": default, computes the â€œleast extremeâ€ LFC, defined as LFC(j) = log2(f_j/f_k) such that k is the topic other than j that gives the ratio f_j/f_k closest to 1.
```{r}
set.seed(1)
# rownames(fit$L) = rownames(counts)
# all(rownames(counts) == rownames(fit$L))
# all(colnames(counts) == rownames(fit$F))

de = de_analysis(fit = fit,X = counts,pseudocount = 0.1, lfc.stat = "le", control= list(nc = 36))
# saveRDS(de, file = sprintf("%s_de_leastextreme.Rds", prefix_topic))
de = readRDS(sprintf("%s_de_leastextreme.Rds", prefix_topic))
pdf(sprintf("%s_de_lse_volcano.pdf", prefix_topic))
for (k in 1:ncol(fit$L)) {
    print(k)
    print(volcano_plot(de,k = k,labels = rownames(de$lfsr)) )
}
dev.off()
for (k in 1:ncol(fit$L)) {
    print(k)
    p = volcano_plotly(de, k = k,file = sprintf("%s_de_leastextreme_volcano_K%s.html",prefix_topic, k), labels = rownames(de$lfsr),ymax = 100)

}

de = de_analysis(fit = fit,X = counts,pseudocount = 0.1, lfc.stat = "vsnull", control= list(nc = 36))
# saveRDS(de, file = sprintf("%s_de_vsnull.Rds", prefix_topic))
de = readRDS(sprintf("%s_de_leastextreme.Rds", prefix_topic))
pdf(sprintf("%s_de_vsnull_volcano.pdf", prefix_topic))
for (k in 1:ncol(fit$L)) {
    print(k)
    print(volcano_plot(de,k = k,labels = rownames(de$lfsr)) )
}
dev.off()


#for HTML visualization 
for (k in 1:ncol(fit$L)) {
    print(k)
    p = volcano_plotly(de, k = k,file = sprintf("%s_de_analysis_volcano_K%s.html",prefix_topic, k), labels = rownames(de$lfsr),ymax = 100)

}

```

Loglik single cell: see below
UMAP from fit$L: see below

**With CORRECTED counts from totalvi_igt1_56_allgenes_Treg_20240306**
```{r}
prefix_topic = "fasttopics_K6_20240521"
prefix_topic = "fasttopics_K30_20240521"
prefix_topic = "fasttopics_K30_20240521_filtgenes"
```

--> fasttopics_K6_20240521_fit.Rds
fasttopics_K30_20240521_fit.Rds
fasttopics_K30_20240521_filtgenes
```{r}
SubsetFit = function(fit, cell.names = names(which(so$is_spleen_healthy == T))) {
    fit$L = fit$L[cell.names,]
    fit$s = fit$s[cell.names]
    return(fit)
}
counts = readMM("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Treg/totalvi_igt1_56_allgenes_Treg_20240306/counts_corrected.mtx")
# REMOVE PROTEIN!!
counts = counts[,1:55487] # REMOVE PROTEIN!!
rownames(counts) = colnames(so)
colnames(counts) = rownames(so)
genes_to_keep = colSums(counts) >0
#if want to remove TCR, mt, ribo, Gm and Rik genes: use this
tcr_genes = colnames(counts)[grepl(x = colnames(counts), pattern = "Trbv|Trbd|Trbj|Trbc|Trav|Traj|Trac|Trbv|Trbd|Trbj|Trbc|Trdv|Trdj|Trdc")]
gm_rik_genes = colnames(counts)[grepl(x = colnames(counts), pattern = "Gm|Rik$")]
ribo_genes = colnames(counts)[grepl(x = colnames(counts), pattern = "Rpl|Rps|Mrpl|Mrps|Rsl")]
mt_genes = colnames(counts)[grepl(x = colnames(counts), pattern = "^mt-")]
genes_to_keep = colSums(counts) >0 & !(colnames(counts) %in% c(tcr_genes, gm_rik_genes, ribo_genes, mt_genes))
length(which(genes_to_keep))

counts = as(counts[,genes_to_keep], Class = "CsparseMatrix")

fit = fit_topic_model(counts,k = 30, numiter.main = 100, numiter.refine = 100,control.init = list(nc = 36), control.main = list(nc = 36),control.refine = list(nc = 36))
# saveRDS(fit, file = sprintf("%s_fit.Rds", prefix_topic))
fit = readRDS(sprintf("%s_fit.Rds", prefix_topic))

dim(fit$L)
dim(fit$F)
pdf(sprintf("%s_convergence.pdf", prefix_topic), 5,5, useDingbats = F)
plot_progress(fit,x = "iter",add.point.every = 10,colors = "black") #+ theme_cowplot(font_size = 10)
dev.off()

topic_colors = mypal[1:ncol(fit$F)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")

pdf(sprintf("%s_structureplot.pdf", prefix_topic), 20,8, useDingbats = F)
structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$organ_simplified)
structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy)
#structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy_igt)
# fit_spleenctrl = fit
# fit_spleenctrl$L = fit$L[so$is_spleen_healthy == T,]
# fit_spleenctrl$s = fit$s[so$is_spleen_healthy == T]
# structure_plot(fit_spleenctrl,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
fit_spleenctrl = SubsetFit(fit, names(which(so$is_spleen_healthy == T)))
structure_plot(fit_spleenctrl,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
dev.off()

pdf(sprintf("%s_UMAP.pdf", prefix_topic), 9,8, useDingbats = F)
for (k in 1:ncol(fit$L) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),1], dim2 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),2], size = fit$L[,k]) 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

set.seed(1)
# rownames(fit$L) = rownames(counts)
# all(rownames(counts) == rownames(fit$L))
# all(colnames(counts) == rownames(fit$F))

de = de_analysis(fit = fit,X = counts,pseudocount = 0.1, lfc.stat = "le", control= list(nc = 36))
saveRDS(de, file = sprintf("%s_de_leastextreme.Rds", prefix_topic))
de = readRDS(sprintf("%s_de_leastextreme.Rds", prefix_topic))
pdf(sprintf("%s_de_lse_volcano.pdf", prefix_topic))
for (k in 1:ncol(fit$L)) {
    print(k)
    print(volcano_plot(de,k = k,labels = rownames(de$lfsr)))
}
dev.off()
pdf(sprintf("%s_de_lse_heatmap.pdf", prefix_topic), 10,15, useDingbats = F)
genes = de$postmean %>% melt() %>% filter(value > 2) %>% group_by(Var2) %>% arrange(desc(value)) %>% top_n(20) %>% arrange(Var2) %>% pull(Var1) %>% as.character()
tmp3 = de$postmean[genes,]
tmp3[tmp3>3] = 3
tmp3[tmp3 < -3] = -3
ColorRamp = viridis(100)
pheatmap(mat = tmp3, cluster_rows = F, cluster_cols = F, col = ColorRamp, fontsize_row = 10, fontsize_col = 10,  main = "FC in top 20 genes in topics")
dev.off()

de = de_analysis(fit = fit,X = counts,pseudocount = 0.1, lfc.stat = "vsnull", control= list(nc = 36))
saveRDS(de, file = sprintf("%s_de_vsnull.Rds", prefix_topic))
de = readRDS(sprintf("%s_de_vsnull.Rds", prefix_topic))
pdf(sprintf("%s_de_vsnull_volcano.pdf", prefix_topic))
for (k in 1:ncol(fit$L)) {
    print(k)
    print(volcano_plot(de,k = k,labels = rownames(de$lfsr)) )
}
dev.off()
pdf(sprintf("%s_de_vsnull_heatmap.pdf", prefix_topic), 10,15, useDingbats = F)
genes = de$postmean %>% melt() %>% filter(value > 2) %>% group_by(Var2) %>% arrange(desc(value)) %>% top_n(20) %>% arrange(Var2) %>% pull(Var1) %>% as.character()
tmp3 = de$postmean[genes,]
# tmp3[tmp3>3] = 3
# tmp3[tmp3 < -3] = -3
ColorRamp = viridis(100)
pheatmap(mat = tmp3, cluster_rows = F, cluster_cols = F, col = ColorRamp, fontsize_row = 10, fontsize_col = 10,  main = "FC in top 20 genes in topics")
dev.off()

```

UMAP from fit$L
```{r}
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = fit$L, key = sprintf("%s_",prefix_topic), assay = "RNA")
so = RunUMAP(so, dims = 1:ncol(fit$L), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s_newUMAP.csv",prefix_topic), quote = F, row.names = TRUE, col.names = TRUE)
tmp = read.csv(sprintf("%s_newUMAP.csv",prefix_topic), header = T, row.names = 1)
so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

prefix = prefix_topic
umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s_newUMAPembedding.pdf", prefix), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

pdf(sprintf("%s_newUMAPembedding_topic.pdf", prefix_topic), 9,8, useDingbats = F)
for (k in 1:ncol(fit$L) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = fit$L[,k]) 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()


```

Visualize poor fit cells
```{r}
loglik = loglik_multinom_topic_model(counts,fit)
pdat = data.frame(loglik = loglik, category = so$IGT)
pdf(sprintf("%s_loglik_cellfit.pdf", prefix_topic), 8, 8, useDingbats = F)
ggplot(pdat,aes(x = loglik,fill = category)) +
  geom_histogram(bins = 64,color = "white",size = 0.25) +
  scale_fill_manual(values = mypal) +
  labs(y = "number of cells") +
  theme_cowplot(font_size = 10)
dev.off()

```

https://stephenslab.github.io/fastTopics/articles/single_cell_rnaseq_practical.html#identifying-clusters-from-the-topic-proportions


**If we want: Predicting topics in other cells**
https://stephenslab.github.io/fastTopics/articles/single_cell_rnaseq_basic.html#predicting-topics-in-other-cells

fasttopics robust? concensus?
calculate spatial autocorrelation of topics?
Flashier to use not count data? ie corrected counts from scvi?

**Flashier**
https://willwerscheid.github.io/flashier/articles/flashier_intro.html

```{r}
prefix = "flashier"
ensure_directory(prefix)
```

log1p with scale factor as the average rowSums(counts)
```{r}
so = readRDS("totalvi_igt1_56_allgenes_Treg_20240529_so.Rds")
norm_fac = mean(so$nCount_RNA)
so = NormalizeData(so, assay = "RNA", normalization.method = "LogNormalize", scale.factor = norm_fac)

counts = so[['RNA']]$counts
shifted_log_counts = so[['RNA']]$data
```

Filter genes
```{r}
genes_to_keep = rowSums(counts) >0
#if want to remove TCR, mt, ribo, Gm and Rik genes: use this
tcr_genes = rownames(counts)[grepl(x = rownames(counts), pattern = "Trbv|Trbd|Trbj|Trav|Traj|Trgv|Trgd|Trgj|Trdv|Trdj")]
gm_rik_genes = rownames(counts)[grepl(x = rownames(counts), pattern = "Gm|Rik$")]
ribo_genes = rownames(counts)[grepl(x = rownames(counts), pattern = "Rpl|Rps|Mrpl|Mrps|Rsl")]
mt_genes = rownames(counts)[grepl(x = rownames(counts), pattern = "^mt-")]
genes_to_keep = rowSums(counts) >0 & !(rownames(counts) %in% c(tcr_genes, gm_rik_genes, ribo_genes, mt_genes))
length(which(genes_to_keep))

counts = t(counts)
counts = counts[,genes_to_keep]

shifted_log_counts = t(shifted_log_counts)
shifted_log_counts = shifted_log_counts[,genes_to_keep]
dim(shifted_log_counts)

```
Spleen healthy 
```{r}

so$is_spleen_healthy = F
so$is_spleen_healthy[so$organ == "spleen" & so$condition_broad == "healthy"] = T
so$is_spleen_healthy_igt = so$is_spleen_healthy
so$is_spleen_healthy_igt[so$is_spleen_healthy == T] = as.character(so$IGT[so$is_spleen_healthy == T])

spl_cells = names(which(so$is_spleen_healthy))

```


Variance regularization:
Before we fit the model, one issue we need to confront is that flashier may automatically estimate the variances to be too small, which can especially be an issue for genes with low expression. We can avoid this issue by setting a sensible lower bound on the variance estimates.
We use the following rule of thumb: estimate the standard deviation of the transformed data for a Poisson random variable with rate ðœ‡=1/, where ð‘›is the number of samples. This standard deviation corresponds to a gene for which we would expect to observe a single count across all ð‘›cells, so it can serve as a reasonable lower bound to prevent variance estimates from getting too small.
```{r}

n = nrow(counts)
x = rpois(1e7, 1/n)
s1 = sd(log(x + 1))

```

Fit a flashier model:
One alternative to NMF that could potentially reveal other interesting substructures is a semi-non-negative matrix factorization (semi-NMF). This is achieved by assigning different priors to ð‹ and ð…: a prior with non-negative support (such as the point-exponential prior) for ð‹; and a prior with support for all real numbers for  (such as the point-Laplace prior). The call to the â€œflashâ€ function looks the same as above except for the â€œebnm_fnâ€ argument:

Specifying the number of factors ð¾is not needed because flashier automatically

backfit = TRUE. This is generally recommended because it improves the quality of the fit. that it may make the model fitting too slow for very large data sets

ebnm_normal: truncated SVD. Poor interpretability
sparse factorization: more interpretatbility
ebnm_point_exponential: non negative (and sparse)
ebnm_point_laplace: all real numbers (and sparse)

F_pm for posterior mean

20240718_k6_pe_pl
```{r}
prefix2 = "20240718_k6_pe_pl"
ensure_directory(sprintf("%s/%s", prefix,prefix2))

fit = flash(shifted_log_counts, 
             ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace), #
             var_type = 2, 
             greedy_Kmax = 6, 
             S = s1,
             backfit = FALSE)

saveRDS(fit, file = sprintf("%s/%s/fit.Rds", prefix,prefix2))
```

20240718_knolim_pe_pl
```{r}
prefix2 = "20240718_knolim_pe_pl"
ensure_directory(sprintf("%s/%s", prefix,prefix2))

fit = flash(shifted_log_counts, 
             ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace), #
             var_type = 2, 
             S = s1,
             backfit = TRUE)

saveRDS(fit, file = sprintf("%s/%s/fit.Rds", prefix,prefix2))
```

20240719_knolim_ebnm_normal
```{r}
prefix2 = "20240719_knolim_ebnm_normal"
ensure_directory(sprintf("%s/%s", prefix,prefix2))

fit = flash(shifted_log_counts, 
             ebnm_fn = ebnm_normal, #
             var_type = 2, 
             S = s1,
             backfit = TRUE)

saveRDS(fit, file = sprintf("%s/%s/fit.Rds", prefix,prefix2))
```


*Plots for flashier*
```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))
#round(fit$L_pm[1:10, ], digits = 3)
```

scree_plot.pdf
```{r}
pdf(sprintf("%s/%s/scree_plot.pdf", prefix, prefix2), 5, 5, useDingbats = F)
plot(fit, include_scree = T, include_pm = F, plot_type = "scree")
dev.off()
```

histogram_loadings_plot.pdf
```{r}
pdf(sprintf("%s/%s/histogram_loadings_plot.pdf", prefix, prefix2), 20, 20, useDingbats = F)
plot(fit, 
     include_scree = F,
     include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings", 
     pm_groups = so$organ_simplified,
     bins = 20,
     pm_colors = mypal[1:length(unique(so$organ_simplified))]) #+ NoLegend()
#dev.off()

plot(fit, 
     include_scree = F,
     include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings", 
     pm_subset = spl_cells,
     pm_groups = so$IGT[so$is_spleen_healthy],
     bins = 20,
     pm_colors = mypal[1:length(unique(so$IGT[so$is_spleen_healthy]))]) +
    ggtitle("Spleen standard only")#+ NoLegend()

dev.off()



#Struture plot not working
# plot(fit, 
#      include_scree = F,
#      include_pm = T,
#      plot_type = "structure",
#      pm_which = "loadings", 
#      pm_groups = so$organ_simplified,
#      bins = 20, 
#      pm_colors = mypal[1:length(unique(so$organ_simplified))]) + NoLegend()

```

factors_volcano.pdf
factors_heatmap.pdf
de_genes_factors.txt
```{r}
message("factors_volcano.pdf")
res = ldf(fit, type = "i")
F1 = with(res, F %*% diag(D)) #same as res$F %*% diag(res$D)
rownames(F1) = colnames(shifted_log_counts)
head(sort(F1[,6], decreasing = TRUE), n = 16)
F1 %>% write.table(sprintf("%s/%s/de_genes_factors.txt", prefix, prefix2), quote = F, sep = "\t", row.names = T, col.names = T)
genes = apply(F1, 2, order, decreasing = TRUE)[1:10, 2:fit$n_factors]
top_genes = rownames(F1)[genes]
top_genes_m  = matrix(rownames(F1)[genes], nrow = nrow(genes), byrow = TRUE)

pdf(sprintf("%s/%s/factors_volcano.pdf", prefix, prefix2), 5, 5, useDingbats = F)
for (i in 1:fit$n_factors) {
    print(i)
    p = plot(fit,
             include_scree = F,
             plot_type = "scatter",
             pm_which = "factors",
             kset = i,
             labels = TRUE,
             n_labels = 50,
             label_size = 2.5) +
        labs(x = "increase in shifted log expression",
             y = "mean shifted log expression") +
        ggtitle(sprintf("k = %s",i))
    print(p)
}
dev.off()

message("factors_heatmap.pdf")
pdf(sprintf("%s/%s/factors_heatmap.pdf", prefix, prefix2), 10,60, useDingbats = F)
tmp3 = F1[top_genes,]
tmp3[tmp3>3] = 3
tmp3[tmp3 < -3] = -3
ColorRamp = viridis(100)
colnames(tmp3) = sprintf("topic%s", 1:ncol(F1))
pheatmap(mat = tmp3, cluster_rows = F, cluster_cols = F, col = ColorRamp, fontsize_row = 10, fontsize_col = 10,  main = "FC in top 20 genes in topics")
dev.off()


```

structure_plot.pdf
ebmfUMAP.pdf: new UMAP from fit$L (row normalized in module_scores_percentile2 for less batch effect)
ebmfUMAP_topics.pdf

```{r}
topic_colors = mypal[1:ncol(fit$L_pm)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")

message("calculate topic_scores_percentile = row normalized L matrix")
#calculate module_scores_percentile for structure plot
percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
module_scores_percentile = apply(fit$L_pm, 2, percentiles)
rownames(module_scores_percentile) = rownames(fit$L_pm)
module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))

message("structure_plot.pdf")
pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20,8, useDingbats = F)
structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25,grouping = so$organ_simplified)
structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy)
#structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy_igt)
#fit_spleenctrl = SubsetFit(fit, names(which(so$is_spleen_healthy == T)))
structure_plot(module_scores_percentile2[names(which(so$is_spleen_healthy)),]/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
dev.off()

message("UMAP_topics.pdf")
pdf(sprintf("%s/%s/UMAP_topics.pdf", prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),1], dim2 = so[["umap_totalvi"]]@cell.embeddings[match(colnames(so),rownames(so[["umap_totalvi"]])),2], size = module_scores_percentile2[,k]) #fit$L_pm[,k]
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

message("ebmfUMAP.csv") #New UMAP from fit$L (module_scores_percentile)
prefix_topic = sprintf("%s_%s",prefix,prefix2)
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = module_scores_percentile2 , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so = RunUMAP(so, dims = 1:ncol(module_scores_percentile2), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), quote = F, row.names = TRUE, col.names = TRUE)
# tmp = read.csv(sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), header = T, row.names = 1)
# so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

# ldfl = ldf(fit,type = "i")$L
# so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = ldfl , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
# so = RunUMAP(so, dims = 1:ncol(ldfl), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))

message("ebmfUMAP.pdf")
umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s/%s/ebmfUMAP_ldfl.pdf",prefix, prefix2), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

message("ebmfUMAP_topics.pdf")
pdf(sprintf("%s/%s/ebmfUMAP_topics.pdf",prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = module_scores_percentile2[,k]) #fit$L_pm[,k] 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()



# ##########If needed: structure_plot equivalent
# percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
# module_scores_percentile = apply(fit$L_pm, 2, percentiles)
# rownames(module_scores_percentile) = rownames(fit$L_pm)
# module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
# colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))
# 
# #single cell UMAP_1D order
# so = RunUMAP(so, dims = 1:30, reduction = "totalvi", n.components = 1, reduction.name = "totalvi_1d")
# all(rownames(so[["totalvi_1d"]]) == rownames(fit$L_pm))
# ord_cells = order(so[["totalvi_1d"]]@cell.embeddings[,1])
# 
# #order the modules
# hc = hclust(dist(t(module_scores_percentile2)))
# ord_modules = hc$order 
# ord_modules = colnames(module_scores_percentile2)[hc$order]
# 
# #pca = prcomp(module_scores_percentile2, scale. = TRUE)
# #pca_1 = pca$x[, 1]
# #ordered_df = as.data.frame(module_scores_percentile2[order(pca_1),])
# ordered_df = as.data.frame(module_scores_percentile2[ord_cells,ord_modules])
# ordered_df$cell_id = factor(rownames(ordered_df), ordered = T)
# melted_df = melt(ordered_df)
# melted_df$variable = factor(melted_df$variable, levels = ord_modules, ordered = T)
# melted_df = melted_df %>% arrange(cell_id)
# 
# pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20,10, useDingbats = F)
# p = ggplot(melted_df, aes(x = cell_id, y = value, fill = variable)) +
#     geom_bar(stat = "identity") +
#     scale_fill_manual(values = mypal)+
#     labs(x = "Cells", y = "Score", fill = "Module") +
#     theme_minimal() +
#     theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#           panel.grid.major = element_blank(), 
#           panel.grid.minor = element_blank(),
#           panel.background = element_blank()
#     )
# print(p)
# dev.off()


```

Which metadata is significantly enriched in a topic?
https://willwerscheid.github.io/flashier/articles/flashier_closer_look.html#sampling-from-the-posterior
One of the list elements in the object returned by flash is a function that can sample from posterior distributions on loadings and factors. Take the backfit above as an example. To better understand which tissues are bound up with whole blood effects, we might like confidence intervals for the third factor. We construct 95% confidence intervals using 200 samples and then finding 2.5% and 97.5% quantiles as follows:
```{r}
# Set seed for reproducibility.
set.seed(1)
# Use returned sampler to sample from posterior.
samp = fit$sampler(nsamp = 200)
# Only keep factor 3.
factor3_samp <- lapply(samp, function(x) x[[2]][, 3])
# Normalize the loadings.
factor3_samp <- sapply(factor3_samp, function(x) x / max(abs(x)))
# Get 95% confidence intervals.
factor3_ci <- apply(factor3_samp, 1, quantile, c(0.025, 0.975))

plot(fit, 
     include_scree = F,
     include_pm = T,
     kset = 3,
     #plot_type = "histogram",
     pm_which = "loadings", 
     pm_groups = so$organ_simplified,
     bins = 20,
     pm_colors = mypal[1:length(unique(so$organ_simplified))]) + geom_errorbar(aes(ymin = factor3_ci[1, ], ymax = factor3_ci[2, ]))

plot(fit, kset = 3, pm_colors = gtex_colors, include_scree = FALSE) + geom_errorbar(aes(ymin = factor3_ci[1, ], ymax = factor3_ci[2, ]))
```







