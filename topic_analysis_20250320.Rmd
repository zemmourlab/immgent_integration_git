---
title: "topic_analysis"
output: html_document
date: "2024-04-30"
editor_options: 
  chunk_output_type: console
---

**Start interactive session on Midway3**
```{bash}
ssh -Y zemmour@midway3.rcc.uchicago.edu
sinfo -s
screen -S david
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=jfkfloor2 --qos=jfkfloor2 --nodes=1 
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=zemmour-hm --qos=zemmour --nodes=1 
sinteractive --time=12:00:00 --account=pi-zemmour --partition=beagle3-bigmem --nodes=1 --mem=128GB
sinteractive --time=12:00:00 --account=pi-zemmour --partition=caslake --nodes=1 --mem=96GB
sinteractive --time=3:00:00 --account=pi-zemmour --partition=gpu --gres=gpu:1 --mem=152GB
cd $LABHOME

module load python/anaconda-2022.05 
module load hdf5/1.12.0 #for BPCells but also others
module load openblas/0.3.13

#sinteractive --time=1:00:00 -p gpu --gres=gpu:1 --account=pi-zemmour 

#source activate /project/jfkfloor2/zemmourlab/david/envs/scvi
source activate /project/zemmour/david/envs/scvi_20240315
module load openblas/0.3.13 #load again or error

cd /project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/
#cd ~/google_drive/ImmgenT/analysis/data_integration/IGT1_56/Treg

#srun --pty --jobid 21908677 -w midway3-0291 /bin/bash

R
#options(max.print=1000)
#options(Seurat.object.assay.version = 'v5')
```

**Initialize in R: load libraries and custom functions**

```{r}
options(max.print=1000)
# setwd("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_96")
source("/project/jfkfloor2/zemmourlab/david/immgent/immgent_integration_git/custom_functions_david.R")

libs = c("fgsea","fastTopics", "flashier", "Matrix", "Seurat","BPCells", "ggplot2","scattermore", "dplyr", "reshape2", "ggrastr", "RColorBrewer", "pals", "scales", "pheatmap", "rafalib", "limma") 
#libs = c("matrixStats", "gplots","ggplot2", "reshape2", "scales", "gridExtra", "dplyr", "RColorBrewer", "grid", "Rtsne", "limma",   "RColorBrewer", "pheatmap", "Seurat",  "ggrastr", "ggbeeswarm") #pwr, preprocessCore, "readxl", vegan", "genefilter" "scde" "cellrangerRkit", "Rsamtools", "GenomicRanges", "GenomicAlignments", "VGAM", "WGCNA",rafalib, ‘UsingR’,MAST "ggrastr",
sapply(libs, function(x) suppressMessages(suppressWarnings(library(x, character.only = TRUE, quietly = T, warn.conflicts  = F))))


#Gradients
library(RColorBrewer)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdYlBu"))(100))
# ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = rev(rainbow(10, end = 4/6))
library(viridis)
ColorRamp = rev(viridis(100))
ColorRamp = rev(cividis(100))
ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = colorRampPalette(c('white','red'))(20)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdBu"))(100))
# ColorRamp = colorRampPalette(c('Red'))(20)
#image(1:100, 1, as.matrix(1:100), col = ColorRamp, main = "Color Palette", xaxt = 'n', yaxt = 'n', xlab = "", ylab = "")

#mycol = c("black","blue","red","darkgreen", "orange","purple", "cyan", "greenyellow",    "salmon", "magenta","pink", "tan", "brown") # c("magenta", "red",  "darkgreen", "cyan", "blue", "blue", "blue", "black", "blue", "blue", "blue", "blue", "orange")

#Large Color palette
library("pals")
n = 70
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
mypal1 = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
mypal1 = mypal1[-4]
mypal = c(glasbey(), polychrome(), mypal1)
names(mypal) = NULL
#pal.bands(mypal, main="Colormap suggestions")
mypal_organ = setNames(mypal, unique(so$organ_simplified))
mypal_organ = mypal_organ[!is.na(names(mypal_organ))]
mypal_level1 = setNames(mypal, unique(so$annotation_level1))
mypal_level1 = mypal_level1[!is.na(names(mypal_level1))]
mypal_level2 = setNames(mypal, unique(so_orig$annotation_level2))
mypal_level2 = mypal_level2[!is.na(names(mypal_level2))]
mypal_level2["CD4_cl18"] = "blue"
mypal_igt = setNames(mypal, unique(so$IGT))
mypal_igt = mypal_igt[!is.na(names(mypal_igt))]


#parade = function(n) { return(Seurat::DiscretePalette(n, palette = "parade", shuffle = F)) }
```

**Flashier**
https://willwerscheid.github.io/flashier/articles/flashier_intro.html

```{r}
# so_orig = readRDS(file = "igt1_96_withtotalvi20250317_clean.Rds")
so_orig = readRDS(file = "igt1_96_withtotalvi20250513_clean.Rds")
so = so_orig


sampled_cellID = read.table("/project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/igt1_96_sampledcells200K.csv", header = F, as.is = T)[,1]
# sampled_cellID %>% write.table("igt1_96_sampledcells200K.csv", quote = F, row.names = F, col.names = F, sep = ",")
# so1 = readRDS(file = "DGE_limma/20250109/igt1_96_withtotalvi20250109_clean_sampled.Rds")
# sampled_cellID = sampled_cellID[!sampled_cellID %in% colnames(so1)[so1$annotation_level2 == "gdT_53"]]

```

flashier20250215_alldata_backfit -- all cells data + backfit + K=200


*Plots for flashier object*
```{r}
prefix = "topic"
prefix2 = "flashier20250215_alldata_backfit"
fit_flash = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))
fit = fit_flash
all(rownames(fit$L_pm) == colnames(so))

```

scree_plot.pdf
```{r}
pdf(sprintf("%s/%s/scree_plot.pdf", prefix, prefix2), 10, 5, useDingbats = F)
plot(fit, plot_type = "scree")
dev.off()

data.frame(factor = sprintf("F%s", 1:ncol(fit$F_pm)), pve = fit$pve) %>% write.table(sprintf("%s/%s/factor_pve.txt", prefix, prefix2), quote = F, sep = "\t", row.names = F, col.names = T)
sum(fit$pve)
order(fit$pve, decreasing = T)
```

histogram_loadings_plot.pdf
```{r}
pdf(sprintf("%s/%s/histogram_loadings_plot.pdf", prefix, prefix2), 40, 40, useDingbats = F)
plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_groups = so$organ_simplified,
     bins = 20,
     pm_colors = mypal_organ) #+ NoLegend()
     # pm_colors = mypal[1:length(unique(so$organ_simplified))]) #+ NoLegend()

plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_groups = so$annotation_level1,
     bins = 20,
     pm_colors = mypal_level1) #+ NoLegend()
     # pm_colors = mypal[1:length(unique(so$organ_simplified))]) #+ NoLegend()

plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_subset = spl_cells,
     pm_groups = so$IGT[so$spleen_standard],
     bins = 20,
     pm_colors = mypal_igt[unique(so$IGT[so$spleen_standard])]) + #mypal[1:length(unique(so$IGT[so$spleen_standard]))]
    ggtitle("Spleen standard only")#+ NoLegend()

dev.off()

pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20, 8, useDingbats = F)
plot(fit,
     plot_type = "structure",
     pm_which = "loadings",
     pm_groups = so$organ_simplified,
     pm_colors = mypal,
     gap = 25) #+ NoLegend()

plot(fit,
     include_scree = F,
     plot_type = "structure",
     pm_which = "loadings",
     pm_groups = so$annotation_level1,
     pm_colors = mypal,
     gap = 25) #+ NoLegend()

plot(fit,
     plot_type = "structure",
     pm_which = "loadings",
     pm_subset = spl_cells,
     pm_groups = so$IGT[so$spleen_standard],
     pm_colors = mypal,
     gap = 25)
dev.off()


```

factors_volcano.pdf
factors_heatmap.pdf
de_genes_factors.txt
```{r}
message("factors_volcano.pdf")
res = ldf(fit, type = "i")
F1 = with(res, F %*% diag(D)) #same as res$F %*% diag(res$D)
# rownames(F1) = colnames(shifted_log_counts)
head(sort(F1[,6], decreasing = TRUE), n = 16)
colnames(F1) = sprintf("F%s", 1:ncol(F1))
F1 = F1[,order(fit$pve, decreasing = T)]
F1 %>% write.table(sprintf("%s/%s/de_genes_factors.txt", prefix, prefix2), quote = F, sep = "\t", row.names = T, col.names = T)
genes = apply(F1, 2, order, decreasing = TRUE)[1:10, 2:fit$n_factors]
top_genes = rownames(F1)[genes]
top_genes_m  = matrix(rownames(F1)[genes], nrow = nrow(genes), byrow = TRUE)

pdf(sprintf("%s/%s/factors_volcano.pdf", prefix, prefix2), 5, 5, useDingbats = F)
for (i in 1:fit$n_factors) {
    print(i)
    p = plot(fit,
             include_scree = F,
             plot_type = "scatter",
             pm_which = "factors",
             kset = i,
             labels = T,
             n_labels = 50,
             label_size = 2.5) +
        labs(x = "increase in shifted log expression",
             y = "mean shifted log expression") +
        ggtitle(sprintf("k = %s",i))
    print(p)
}
dev.off()

message("factors_heatmap.pdf")
pdf(sprintf("%s/%s/factors_heatmap.pdf", prefix, prefix2), 10,40, useDingbats = F)
tmp3 = F1[top_genes,]
tmp3[tmp3>3] = 3
tmp3[tmp3 < -3] = -3
# ColorRamp = viridis(100)
colnames(tmp3) = sprintf("factor%s", 1:ncol(F1))
pheatmap(mat = tmp3, cluster_rows = F, cluster_cols = F, col = ColorRamp, fontsize_row = 1, fontsize_col = 1,  main = "FC in top 20 genes in topics")
dev.off()


```

**L1**

```{r}

L1 = with(ldf(fit, type = "i"), L %*% diag(D)) #same as res$F %*% diag(res$D)
# L1 = with(ldf(fit, type = "i"), L) 
# L1 = with(ldf(fit, type = "i"), L) 
# rownames(F1) = colnames(shifted_log_counts)
# head(sort(F1[,6], decreasing = TRUE), n = 16)
colnames(L1) = sprintf("F%s", 1:ncol(L1))

all(rownames(L1) == colnames(so))
L1 = L1[colnames(so),]
all(rownames(L1) == colnames(so))

mdata_orig = data.frame(so@meta.data,L1)
# shist(mdata_orig$F1)
# max(mdata_orig[mdata_orig$spleen_standard == T,grepl("^F",colnames(mdata_orig))])
# mdata_orig %>% write.table(file = sprintf("%s/%s/loadings_withmetadata.tsv", prefix, prefix2), quote = F, row.names = F, col.names = T, sep = "\t")

#for Laurent
# tmp = so[,rownames(L1)]
# L1 = L1[colnames(tmp),]
# mdata_orig = data.frame(tmp@meta.data,L1)
# mdata_orig %>% write.table(file = sprintf("%s/%s/loadings_withmetadata.tsv", prefix, prefix2), quote = F, row.names = F, col.names = T, sep = "\t")

```

#162 has Il22
```{r}

plot(L1[,1], L1[,162], pch = ".", log = "x"  )
```


**Flagging batch specific topics **
9, 49, 171
Limma with spleen control
```{r}
library(limma)
mdata = mdata_orig[mdata_orig$spleen_standard == T,]
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

pdf(sprintf("%s/%s/spleenctrl_factors_boxplots.pdf", prefix, prefix2), 20,10, useDingbats = F)
for (i in colnames(mdata)[grepl("^F",colnames(mdata))]) {
    print(i)
    p = ggplot(mdata[mdata$spleen_standard == T,], aes(IGT, !!sym(i))) + 
        geom_boxplot(aes(fill = IGT, group = IGT) ) + 
        # ylim(0,ceiling(max(mdata[mdata$spleen_standard == T,grepl("^F",colnames(mdata))]))) +
        scale_fill_manual(values = mypal_igt) + theme_bw() + 
        ggtitle(label = sprintf("%s", i)) # + theme_bw()+ ggtitle(label = "F1 IGT") + theme(axis.text.x  = element_text(angle=75, vjust=0.5, size=10)
    print(p)
}
dev.off()

#limma model
# factor_means = mdata %>% filter(mdata$spleen_standard == T) %>% group_by(IGT) %>% summarize_at(vars(matches("^F")), mean) %>% as.data.frame()
# factor_means = factor_means[order(extract_numeric(factor_means$IGT)),]
# rownames(factor_means) = factor_means$IGT
# factor_means = factor_means[,-1]
# factor_means = t(factor_means)


# Create the design matrix for the linear model
design = model.matrix(~ 0 + IGT, data = mdata[mdata$spleen_standard == T,])
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[mdata$spleen_standard == T, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# Apply empirical Bayes moderation
fit2 = eBayes(fit)
# Extract p-values for all comparisons
adj_pvalues = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH")

pvmat = adj_pvalues
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/spleenctrl_factors_heatmap.pdf", prefix, prefix2), 20,20, useDingbats = F)
# pheatmap(factor_means, cluster_rows = F, cluster_cols = F, display_numbers = labels_matrix, main = "mean from LD")
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()

```

**Limma with annotation level1: ~ 0 + annotation_level1 + IGTHT**

all cells ~ 0 + annotation_level1 + IGTHT
```{r}
prefix3 = "limma/20250320_level1_IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGTHT, data = mdata)
colnames(design) = gsub("annotation_level1|IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

sampled cells ~ 0 + annotation_level1 + IGTHT
```{r}
prefix3 = "limma/20250320_level1_IGTHT_sampled"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig[sampled_cellID,]
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGTHT, data = mdata)
colnames(design) = gsub("annotation_level1|IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

all cells ~ 0 + annotation_level1 + IGT
```{r}
prefix3 = "limma/20250323_level1_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGT, data = mdata)
colnames(design) = gsub("annotation_level1", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

**Limma with annotation level2**
~ 0 + annotation_level2 + IGT

```{r}
prefix3 = "limma/20250323_level2_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level2 =  factor(mdata$annotation_level2, levels = names(which(!table( mdata$annotation_level2)==0)))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level2 + IGT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("annotation_level2", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level2) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level2)) {
    print(cl)
    group1_filter <- expr(annotation_level2 == cl)
    group2_filter <- expr(!(annotation_level2 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level2")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,30, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()

pdf(sprintf("%s/%s/%s/heatmap_filtered.pdf", prefix, prefix2, prefix3), 20,10, useDingbats = F)
sub = fit_flash$pve > 10^-4 | rowSums(abs(fit2$coefficients) > 0.5) >= 1
pheatmap(fit2$coefficients[sub,], cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix[sub,], main = "fit2$coefficients fit_flash$pve > 10^-4 | rowSums(abs(fit2$coefficients) > 0.5) > 1")
pheatmap(fit2$coefficients[sub,], cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix[sub,], main = "fit2$coefficients fit_flash$pve > 10^-4 | rowSums(abs(fit2$coefficients) > 0.5) > 1")
dev.off()

fit$pve


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))




#################
message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
# saveRDS(fit2, file = sprintf("%s/%s/fit_limma_level2_IGTHT_constrastfit.Rds", prefix, prefix2))
fit2 = readRDS(sprintf("%s/%s/fit_limma_level2_IGTHT_constrastfit.Rds", prefix, prefix2))
# Extract p-values for all comparisons
adj_pvalues = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH")
# write.table(results, file = sprintf("%s/%s/fit_limma_leve2_IGTHT_table.txt", prefix, prefix2), quote = F, row.names = T, col.names = T, sep = ",")

pvmat = adj_pvalues
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/fit_limma_level2_IGTHT_heatmap.pdf", prefix, prefix2), 20,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


```

do ~ 0 + annotation_level2 + IGTHT ?

**Limma with organ in healthy**
~ 0 + organ_simplified + IGT

```{r}
prefix3 = "limma/20250324_organsimplified_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig %>% filter(condition_broad == "healthy") %>% as.data.frame()
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

mdata$organ_simplified = make.names(mdata$organ_simplified)
mdata$organ_simplified =  factor(mdata$organ_simplified, levels = names(which(!table( mdata$organ_simplified)==0)))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + organ_simplified + IGT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("organ_simplified", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(organ_simplified) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$organ_simplified)) {
    print(cl)
    group1_filter <- expr(organ_simplified == cl)
    group2_filter <- expr(!(organ_simplified %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "organ_simplified")
    nmecontrast = sprintf("%s_vs_AllinHealthy", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

**Topics in CD4**

Th1 topics
26: Ifng, ccl5 etc
X10
X26

Th2 topics
56: IL4, il13
159: Il1rl1 gata3 areg
X25

Th17 topics
152: Treg_cl8 (Maf, Il10, Ctla4)
161: Il17a (PD1, Nr4a1)
72: IL22, Bhlh240, Odc1
36

```{r}
so = so_orig[,so_orig$annotation_level1 == "CD4" & !so_orig$annotation_level2 %in% c("CD4_miniverse", "CD4_prolif")]
L1 = with(ldf(fit, type = "i"), L) #same as res$F %*% diag(res$D)

cd4_l1 = data.frame(so@meta.data,L1[colnames(so),])
cd4_l1 = cd4_l1 %>% mutate(th1 = X10+X25+X26,th2 = X56+X159+X25, th17 = X161+X72+X36+X13)
cd4_l1 = cd4_l1 %>% mutate(th1 = X26+X10,th2 = X56, th17 = X161)


# p = ggplot(cd4_l1) + geom_scattermore(aes(X10, X159, color = annotation_level2), pointsize = 1, alpha = 1, pixels = c(512,512)) + scale_color_manual(values = mypal_level2) + ggtitle("") + theme_minimal() + NoLegend()
# p

# p = ggplot(cd4_l1 %>% filter(annotation_level2_group %in% c("activated") )) + geom_point(aes(X10, X159, color = annotation_level2), size = 0.1,alpha = 0.5) + xlim(c(0,0.0025)) + scale_color_manual(values = mypal_level2) + ggtitle("") + theme_minimal() + NoLegend()
# p + facet_wrap(~annotation_level2)

# pdf(sprintf("%s/%s/CD4_th_topics_scatter.pdf", prefix, prefix2), 6, 6, useDingbats = F)
pdf(sprintf("%s/%s/CD4_th_topics_scatter_split.pdf", prefix, prefix2), 20, 20, useDingbats = F)
p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th1 + 0.01), log(th2 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    xlim(c(min(log(cd4_l1$th1+0.01)),-2)) +
    ggtitle("") + 
    theme_minimal() 
# p 
# p + NoLegend()
p+facet_wrap(~annotation_level2)

p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th1 + 0.01), log(th17 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    xlim(c(min(log(cd4_l1$th1+0.01)),-2)) +
    ggtitle("") + 
    theme_minimal() + 
    NoLegend()
# p
p+facet_wrap(~annotation_level2)


p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th17 + 0.01), log(th2 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    ggtitle("") + 
    theme_minimal() + 
    NoLegend()
# p
p+facet_wrap(~annotation_level2)
dev.off()


pdf(sprintf("%s/%s/CD4_th_topics_violin.pdf", prefix, prefix2), 10, 7, useDingbats = F)
p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th17 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th17 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p

p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th1 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th1 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p

p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th2 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th2 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p
dev.off()




```

Gene dot plot
```{r}
F1 = with(ldf(fit, type = "i"), F)
colnames(F1) = paste("F", 1:ncol(F1), sep = "")
top_genes = apply(F1, 2, order, decreasing = TRUE)[1:10, c("F26","F56","F161")]
top_genes = unique(c("Ifng",rownames(fit$F_pm)[top_genes]))
top_genes


plot_data = melt(F1[top_genes,c("F26","F56","F161")], varnames = c("Gene", "Factor"), value.name = "Expression")

# Create the dot plot

pdf(sprintf("%s/%s/CD4_genematrix_topicsTh1217.pdf", prefix, prefix2), 3, 7, useDingbats = F)
p = ggplot(plot_data, aes(x = Factor, y = Gene, fill = Expression, alpha = Expression)) +
  geom_tile(width = 0.9, height = 0.9) +  # Adjust the width and height for the gaps
  scale_fill_gradient(low = "white", high = "brown") +  # Adjust color gradient
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    panel.grid = element_blank(),  # Remove gridlines
    panel.border = element_blank()  # Optional: remove the border around the plot
  ) +
    scale_y_discrete(limits = rev(levels(plot_data$Gene))) + 
  coord_fixed(ratio = 1) +  # Ensure tiles are square
  labs(title = "Dot Plot (Squares) of Gene Expression", x = "Layer", y = "Gene")
print(p)
dev.off()
```

Tfh/Tex FC FC plot
```{r}
source('/Users/david/Library/CloudStorage/GoogleDrive-david.puyraimond@gmail.com/My Drive/ImmgenT/analysis/immgent_integration_git/custom_functions_david.R')

tt_list = readRDS('/Users/david/Library/CloudStorage/GoogleDrive-zemmour@uchicago.edu/My Drive/ImmgenT/analysis/data_integration/IGT1_96/CD4/DGE_limma/20250109/ttlist_OneVsAll.Rds')

names(tt_list)

vplot = data.frame(fc1 = exp(tt_list$CD4_cl14_vs_All$logFC), fc2 = exp(tt_list$CD4_cl13_vs_All$logFC))

FCFCplot(vplot)
genes_to_plot = abs(tt_list$CD4_cl14_vs_All$logFC >2 | tt_list$CD4_cl13_vs_All$logFC >2)
plot(tt_list$CD4_cl14_vs_All$logFC, tt_list$CD4_cl13_vs_All$logFC, pch = ".")

# Load necessary libraries
library(ggplot2)
library(scales)  # For log transformation
library(ggrepel)

# Define the FCFCplot function
FCFCplot = function(vplot, xlab = "fc1", ylab = "fc2", main = "", printgeomtext = T, 
                    xlimits = c(0.1, 10), ylimits = c(0.1, 10), genes_to_label = NULL) {
    # Create the base plot
    p = ggplot(data = vplot) + 
        geom_point(aes(x = fc1, y = fc2), colour = "black", alpha = I(1), size = I(0.5)) +
        scale_x_continuous(trans = log_trans(10), breaks = c(0.125,0.5, 1, 2,5, 10),  
                           labels = c(0.125,0.5, 1, 2,5, 10), limits = xlimits) +
        scale_y_continuous(trans = log_trans(10), breaks = c(0.125,0.5, 1, 2,5, 10),  
                           labels = c(0.125,0.5, 1, 2,5, 10), limits = ylimits) +
        geom_hline(aes(yintercept = 1), linetype="dashed", color = "brown") +
        geom_vline(aes(xintercept = 1), linetype="dashed", color = "brown") +
        annotation_logticks(sides = "bl") +
        xlab(xlab) +
        ylab(ylab) +
        ggtitle(main) +
        theme_bw() +
        theme(axis.text.x  = element_text(size=15,angle = 0, hjust = 1), 
              axis.text.y  = element_text(size=15), 
              legend.text=element_text(size=20), 
              axis.title.x = element_text(size=20) , 
              axis.title.y = element_text(size=20))
    
    # Add labels for specific genes if requested
    if (printgeomtext & !is.null(genes_to_label)) {
        p = p + geom_text_repel(data = genes_to_label, aes(x = fc1, y = fc2, label = SYMBOL), 
                                 size = 3, color = "red", box.padding = 0.35, 
                                 point.padding = 0.5, segment.color = 'grey50', max.overlaps = 20)
    }
    
    return(p)
}

# Create the vplot dataframe with fold changes
vplot = data.frame(fc1 = exp(tt_list$CD4_cl14_vs_All$logFC), fc2 = exp(tt_list$CD4_cl13_vs_All$logFC), SYMBOL = tt_list$CD4_cl14_vs_All$SYMBOL)

# Identify genes with large fold changes (>2)
genes_to_plot = abs(tt_list$CD4_cl14_vs_All$logFC) > 0.69 | abs(tt_list$CD4_cl13_vs_All$logFC) > 0.69
genes_to_label = vplot[genes_to_plot, ]

# Create the plot
FCFCplot(vplot, 
         xlab = "FC for CD4_cl14", 
         ylab = "FC for CD4_cl13", 
         main = "Fold Change vs Fold Change", 
         printgeomtext = T, 
         genes_to_label = genes_to_label)


```





################

lm with organ in healthy: ~ 0 + organ_simplified + IGT + annotation_level1

```{r}
prefix3 = "limma/20250218_organsimplified_IGT_level1"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig %>% filter(condition_broad == "healthy") %>% as.data.frame()
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

mdata$organ_simplified = make.names(mdata$organ_simplified)
mdata$organ_simplified =  factor(mdata$organ_simplified, levels = names(which(!table( mdata$organ_simplified)==0)))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + organ_simplified + IGT + annotation_level1, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("organ_simplified|annotation_level1", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(organ_simplified) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$organ_simplified)) {
    print(cl)
    group1_filter <- expr(organ_simplified == cl)
    group2_filter <- expr(!(organ_simplified %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "organ_simplified")
    nmecontrast = sprintf("%s_vs_AllinHealthy", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
# saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))

```

lm with sample: 0 + IGTHT --> What samples are enriched in each GP? to find the samples for the low PVE topics

```{r}
prefix3 = "limma/20250218_IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))

# Create the design matrix for the linear model
design = model.matrix(~ 0  + IGTHT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(IGTHT) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$IGTHT)) {
    print(cl)
    group1_filter <- expr(IGTHT == cl)
    group2_filter <- expr(!(IGTHT %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "IGTHT")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 60,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


# Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 &
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))



```

lm with level2_IGTHT: 0 + annotation_level2_IGTHT --> Error in qr.default(x) : too large a matrix for LINPACK
lm with level1_IGTHT: 0 + annotation_level2_IGTHT --> Error in qr.default(x) --> What level 2 in each samples is enriched in each GP? to find the samples for the low PVE topics

```{r}
prefix3 = "limma/20250219_level1IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$annotation_level1 =  factor(mdata$annotation_level1, levels = names(which(!table( mdata$annotation_level1)==0)))
mdata$annotation_level1_IGTHT = factor(paste(mdata$annotation_level1,mdata$IGTHT,sep = "_"))

# Create the design matrix for the linear model
design = model.matrix(~ 0  + annotation_level1_IGTHT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("annotation_level1_IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1_IGTHT) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1_IGTHT)) {
    print(cl)
    group1_filter <- expr(annotation_level1_IGTHT == cl)
    group2_filter <- expr(!(annotation_level1_IGTHT %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1_IGTHT")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 60,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


# Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 &
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))



```


structure_plot.pdf
ebmfUMAP.pdf: new UMAP from fit$L (row normalized in module_scores_percentile2 for less batch effect)
ebmfUMAP_topics.pdf

```{r}
topic_colors = mypal[1:ncol(fit$L_pm)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")

message("calculate topic_scores_percentile = row normalized L matrix")
#calculate module_scores_percentile for structure plot
res = ldf(fit, type = "i")
loadings = with(res, L %*% diag(D)  ) #same as res$L %*% diag(res$D)
#factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
#ldf = with(res, L %*% diag(D) %*% t(F) )
colnames(loadings) = sprintf("factor%s", 1:ncol(fit$L_pm))
#remove_topic = "factor2"
loadings = loadings[,!colnames(loadings) %in% remove_topic]
percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
module_scores_percentile = apply(loadings, 2, percentiles)
rownames(module_scores_percentile) = rownames(loadings)
module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
#colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))


pdf(sprintf("%s/%s/structure_plot_module_scores_percentile.pdf", prefix, prefix2), 20,8, useDingbats = F)
structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25,grouping = so$organ_simplified)
#structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25,grouping = so$is_spleen_healthy)
#structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy_igt)
#fit_spleenctrl = SubsetFit(fit, names(which(so$is_spleen_healthy == T)))
structure_plot(module_scores_percentile2[names(which(so$is_spleen_healthy)),]/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
dev.off()

pdf(sprintf("%s/%s/UMAP_module_scores_percentile.pdf", prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[,1], dim2 = so[["umap_totalvi"]]@cell.embeddings[,2], size = module_scores_percentile2[,k]) #fit$L_pm[,k] #match(colnames(so),rownames(so[["umap_totalvi"]]))
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

pdf(sprintf("%s/%s/UMAP_factors.pdf", prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(loadings) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[,1], dim2 = so[["umap_totalvi"]]@cell.embeddings[,2], size = loadings[,k]) #fit$L_pm[,k] #match(colnames(so),rownames(so[["umap_totalvi"]]))
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

#message("ebmfUMAP.csv") #New UMAP from fit$L (module_scores_percentile)
prefix_topic = sprintf("%s_%s",prefix,prefix2)
#so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = res , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = module_scores_percentile2 , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so = RunUMAP(so, dims = 1:ncol(module_scores_percentile2), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile.csv",prefix, prefix2), quote = F, row.names = TRUE, col.names = TRUE)

# tmp = read.csv(sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), header = T, row.names = 1)
# so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

# ldfl = ldf(fit,type = "i")$L
# so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = ldfl , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
# so = RunUMAP(so, dims = 1:ncol(ldfl), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))

umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile.pdf",prefix, prefix2), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

pdf(sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile_withmodules.pdf",prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = module_scores_percentile2[,k]) #fit$L_pm[,k] 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()


prefix_topic = sprintf("%s_%s",prefix,prefix2)
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = loadings , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so = RunUMAP(so, dims = 1:ncol(loadings), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s/%s/ebmfUMAP_fomLD.csv",prefix, prefix2), quote = F, row.names = TRUE, col.names = TRUE)

# tmp = read.csv(sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), header = T, row.names = 1)
# so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

# ldfl = ldf(fit,type = "i")$L
# so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = ldfl , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
# so = RunUMAP(so, dims = 1:ncol(ldfl), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))

message("ebmfUMAP.pdf")
umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s/%s/ebmfUMAP_fromLD.pdf",prefix, prefix2), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

message("ebmfUMAP_topics.pdf")
pdf(sprintf("%s/%s/ebmfUMAP_fromLD_withfactors.pdf",prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(loadings) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = loadings[,k]) #fit$L_pm[,k] 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Factor %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()



# ##########If needed: structure_plot equivalent
# percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
# module_scores_percentile = apply(fit$L_pm, 2, percentiles)
# rownames(module_scores_percentile) = rownames(fit$L_pm)
# module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
# colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))
# 
# #single cell UMAP_1D order
# so = RunUMAP(so, dims = 1:30, reduction = "totalvi", n.components = 1, reduction.name = "totalvi_1d")
# all(rownames(so[["totalvi_1d"]]) == rownames(fit$L_pm))
# ord_cells = order(so[["totalvi_1d"]]@cell.embeddings[,1])
# 
# #order the modules
# hc = hclust(dist(t(module_scores_percentile2)))
# ord_modules = hc$order 
# ord_modules = colnames(module_scores_percentile2)[hc$order]
# 
# #pca = prcomp(module_scores_percentile2, scale. = TRUE)
# #pca_1 = pca$x[, 1]
# #ordered_df = as.data.frame(module_scores_percentile2[order(pca_1),])
# ordered_df = as.data.frame(module_scores_percentile2[ord_cells,ord_modules])
# ordered_df$cell_id = factor(rownames(ordered_df), ordered = T)
# melted_df = melt(ordered_df)
# melted_df$variable = factor(melted_df$variable, levels = ord_modules, ordered = T)
# melted_df = melted_df %>% arrange(cell_id)
# 
# pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20,10, useDingbats = F)
# p = ggplot(melted_df, aes(x = cell_id, y = value, fill = variable)) +
#     geom_bar(stat = "identity") +
#     scale_fill_manual(values = mypal)+
#     labs(x = "Cells", y = "Score", fill = "Module") +
#     theme_minimal() +
#     theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#           panel.grid.major = element_blank(), 
#           panel.grid.minor = element_blank(),
#           panel.background = element_blank()
#     )
# print(p)
# dev.off()


```

*GSEA analysis on Treg sig**
--> GSEA_signatures.Rda
```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

message("Loading signatures")
load("/project/zemmour/david/signatures/mouse/signaturelist20171024.Rda")
signaturelist1 = signaturelist

load("/project/zemmour/david/signatures/mouse/signaturelistGSEA.Rda")
signaturelist2 = signaturelist

signaturelist = c(signaturelist1, signaturelist2)
names(signaturelist)

signaturelist = signaturelist[grepl("Treg|treg|TREG|TCELL", names(signaturelist))]
#names(signaturelist)[grepl("Treg|treg|Foxp3", names(signaturelist))]
#names(signaturelist)[grepl("IPEX", names(signaturelist))]

message("Calculating GSEA enrichement of Kait topic genes in each of David's factors")
pvalsig = list()
pvalcol = list()
fgseaRes_list = list()
for (f in 1:ncol(factors)) {
    print(f)
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = factors[,f], pval = exp(mean_shifted_log_counts))
    ranks = vplot$fc
    names(ranks) = vplot$SYMBOL
    fgseaRes = fgseaMultilevel(signaturelist, ranks, scoreType = "pos", minSize = 5)
    fgseaRes_list[[as.character(f)]] = fgseaRes
    pvalsig[[as.character(f)]] = fgseaRes$pval
    pvalcol[[as.character(f)]] = fgseaRes$NES
    #head(fgseaRes[order(padj, -abs(NES)), ], n=10)
    #plotEnrichment(signaturelist[["kait_topic_14"]], ranks)
}
#saveRDS(fgseaRes_list,file = sprintf("%s/%s/GSEA_signatures.Rda",prefix, prefix2))
fgseaRes_list = readRDS(sprintf("%s/%s/GSEA_signatures.Rda",prefix, prefix2))
names(fgseaRes_list) = colnames(factors)
fgseaRes_melt = fgseaRes_list
for (i in names(fgseaRes_melt)) {
    fgseaRes_melt[[i]][,"factor"] = i
}
fgseaRes_melt = do.call(rbind, fgseaRes_melt)

pdf(sprintf("%s/%s/GSEA_volcano_by_factor.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:ncol(factors)) {
    print(i)
    vplot = data.frame(SYMBOL = unlist(fgseaRes_list[[i]][,"pathway"]), fc = unlist(fgseaRes_list[[i]][,"NES"]), pval = unlist(fgseaRes_list[[i]][,"padj"]))
    p = Vplot(vplot = vplot, xlab = "", xlimits = c(1,2), ylimits = NULL) + ggtitle(names(fgseaRes_list)[i])
    #sub = vplot$pval < 0.05
    sub = vplot %>% filter(pval < 0.05) %>% arrange(desc(abs(log2(fc)))) %>% slice_head(n = 10) %>% rownames() #select(SYMBOL) %>% as.vector()
    #sub = vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:10]
    q = p + geom_text_repel(data = vplot[sub,], aes(x = fc, y = pval, label = SYMBOL, size = 1))
    print(q)
}
dev.off()


fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, padj, NES, size, factor) %>% slice_head(n = 2)
fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, factor, padj) %>% slice_head(n = 2) %>% as.data.frame()
fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, factor, padj) %>% as.data.frame()
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
colnames(pvalsig_df) = names(signaturelist)
rownames(pvalsig_df) = colnames(factors)
tmp = log10(pvalsig_df)
tmp[tmp > log10(0.05)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(100), main = "GSEA enrichement of Kait topic genes in each of David's factors")
dev.off()


```

*LD correlation with T cell activation?*

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

loadings = with(res, L %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(loadings) = sprintf("david.factor.%s", 1:ncol(loadings))
rownames(loadings) == colnames(so)

plot(so[["ADT"]]@counts["CD62L",], rowSums(loadings))
spl_cells
lm(so[["ADT"]]@counts["CD62L",] ~ rowSums(loadings))

rmcells = names(which(so[["ADT"]]@counts["CD44",] == 0))
so2 = so[,!colnames(so) %in% rmcells]
load_sum = rowSums(loadings)[!colnames(so) %in% rmcells]

DefaultAssay(so2) = "ADT"
#so = NormalizeData(so, assay = "ADT", normalization.method = "CLR")
so2 = NormalizeData(so2, assay = "ADT", normalization.method = "LogNormalize")
plot(so2[["ADT"]]@data["CD62L",], so2[["ADT"]]@data["CD44",])
pdf(sprintf("%s/%s/sumLxCD44_CD62L.pdf", prefix, prefix2), 10,10, useDingbats = F)
cr = cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so2[["ADT"]]@data["CD44",], load_sum, pch = 16, main = sprintf("cor = %s, p = %s", cr$estimate, cr$p.value))
cr = cor.test(so2[["ADT"]]@data["CD62L",], load_sum)
plot(so2[["ADT"]]@data["CD62L",], load_sum, pch = 16, main = sprintf("cor = %s, p = %s", cr$estimate, cr$p.value))
dev.off()

cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so2[["ADT"]]@data["CD44",], load_sum)
cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so[["ADT"]]@data["CD44",], rowSums(loadings))
plot(so[["ADT"]]@data["CD62L",spl_cells], rowSums(loadings)[spl_cells])
plot(so[["ADT"]]@data["CD44",spl_cells], rowSums(loadings)[spl_cells])

plot(so[["ADT"]]@data["CD62L",], 1.5^(rowSums(loadings)))
plot(so[["ADT"]]@data["CD62L",], 1.5^(rowSums(loadings)[]))
plot(so[["ADT"]]@data["CD62L",!colnames(so) %in% spl_cells], 1.5^(rowSums(loadings)[!colnames(so) %in% spl_cells]))

```

**DGE topic**
linear model with level2, organ_simplified, condition_detailed
1. Cosmology: Cell type-specific topics? Or combination of topics (Topic shared across cell type?)
Calculate for each level2 signature how much it is explained by a combination of topics? simple correlation?
2. Other topics that correlate with what? tissues? disease? Tissue-specific topics?

```{r}

```




**Compare topics with Kait's**
GSEA analysis works much better

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

kait_topics = read.table("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Treg/topic_scrna_gene.csv", header = T, sep = ",")
kait_topics = kait_topics[kait_topics$gene %in% colnames(shifted_log_counts),]
kait_topics_list = kait_topics %>% group_by(topic) %>% group_split() %>% as.list() %>% lapply(.,as.data.frame)
names(kait_topics_list) = lapply(kait_topics_list, function(x) x[1,2]) %>% unlist() %>% gsub(.,pattern = "Topic_",replacement = "kait_topic_")
kait_topics_list = lapply(kait_topics_list, function(x) as.character(x[,1]))
signaturelist = kait_topics_list

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

message("Plot gene erichemtn  genechiSq enrichement of Kait topic genes in each of David's factors")
pdf(sprintf("%s/%s/KaitTopicGenes_inDavidFactors_heatmaps_FDR10p.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:length(kait_topics_list)) {
    print(i)
    factors_sub = factors[kait_topics_list[[i]],]
    
    # meta_col =  data.frame(pv = pvalsig_df[,names(kait_topics_list)[i]] < 0.05, stringsAsFactors = F)
    # meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    # rownames(meta_col) = colnames(tmp)
    
    meta_col =  data.frame(pv = tmp[,names(kait_topics_list)[i]] < 0, stringsAsFactors = F) #pvalsig_df[,names(kait_topics_list)[i]] < 0.05 & pvalcol_df[,names(kait_topics_list)[i]]
    meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    rownames(meta_col) = colnames(factors_sub)
    
    annotation_colors = list()
    annotation_colors[["pv"]] = c(signif = "red", notsignif = "grey")
    
    pheatmap(factors[kait_topics_list[[i]],], color = magma(10), cluster_cols = T, cluster_rows = T, annotation_col = meta_col, annotation_colors = annotation_colors, main = sprintf("%s genes in david's factors, value = increase in log1p by the factor", names(kait_topics_list)[i]))
}
dev.off()


message("Calculating GSEA enrichement of Kait topic genes in each of David's factors")
pvalsig = list()
pvalcol = list()
for (f in 1:ncol(factors)) {
    print(f)
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = factors[,f], pval = exp(mean_shifted_log_counts))
    ranks = vplot$fc
    names(ranks) = vplot$SYMBOL
    fgseaRes = fgseaMultilevel(signaturelist, ranks, scoreType = "pos")
    pvalsig[[as.character(f)]] = fgseaRes$pval
    pvalcol[[as.character(f)]] = fgseaRes$NES
    #head(fgseaRes[order(padj, -abs(NES)), ], n=10)
    #plotEnrichment(signaturelist[["kait_topic_14"]], ranks)
}
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
colnames(pvalsig_df) = names(signaturelist)
rownames(pvalsig_df) = colnames(factors)
tmp = log10(pvalsig_df)
tmp[tmp > log10(0.05)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(100), main = "GSEA enrichement of Kait topic genes in each of David's factors")
dev.off()

message("Plot gene erichemtn  genechiSq enrichement of Kait topic genes in each of David's factors")
pdf(sprintf("%s/%s/KaitTopicGenes_inDavidFactors_heatmaps_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:length(kait_topics_list)) {
    print(i)
    factors_sub = factors[kait_topics_list[[i]],]
    
    # meta_col =  data.frame(pv = pvalsig_df[,names(kait_topics_list)[i]] < 0.05, stringsAsFactors = F)
    # meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    # rownames(meta_col) = colnames(tmp)
    
    meta_col =  data.frame(pv = tmp[,names(kait_topics_list)[i]] < 0, stringsAsFactors = F) #pvalsig_df[,names(kait_topics_list)[i]] < 0.05 & pvalcol_df[,names(kait_topics_list)[i]]
    meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    rownames(meta_col) = colnames(factors_sub)
    
    annotation_colors = list()
    annotation_colors[["pv"]] = c(signif = "red", notsignif = "grey")
    
    pheatmap(factors[kait_topics_list[[i]],], color = magma(100), cluster_cols = T, cluster_rows = T, annotation_col = meta_col, annotation_colors = annotation_colors, main = sprintf("%s genes in david's factors, value = increase in log1p by the factor", names(kait_topics_list)[i]))
}
dev.off()

#Not as good but works:
message("Calculating chiSq enrichement of Kait topic genes in each of David's factors")
# pvalsig = matrix(nrow = ncol(factors), ncol = length(signaturelist) )
# pvalcol = matrix(nrow = ncol(factors), ncol = length(signaturelist) )
pvalsig = list()
pvalcol = list()
for (f in 1:ncol(factors)) {
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = exp(factors[,f]), pval = exp(mean_shifted_log_counts))
    #p = Vplot(vplot = vplot, xlab = i, xlimits = NULL, ylimits = NULL)
    
    #Calculate p and q for signatures for factor f
    pvalsig[[as.character(f)]] = c()
    pvalcol[[as.character(f)]] = c()
    for (i in 1: length(signaturelist)) {
        if ((i %% 100) == 0) {print(i)}
        tryCatch({
            sig = names(signaturelist)[i]
            vplot[,sig] = vplot$SYMBOL %in% signaturelist[[i]]
            a = length(which(vplot$fc < 1))
            b = length(which(vplot$fc > 1))
            c = length(which(vplot$fc[vplot[,sig]] < 1))
            d = length(which(vplot$fc[vplot[,sig]] > 1))
            cont_table = rbind(total = c(round(a/(a+b)*(c+d)), round(b/(a+b)*(c+d))), geneset = c(c, d))
            colnames(cont_table) = c("FC<1", "FC>1")
            c = chisq.test(cont_table)
            #pvalsig[[as.character(f)]][sig] = data.frame(pval = c$p.value, is_up = cont_table[2,2] > cont_table[1,2]  )
            pvalsig[[as.character(f)]][sig] = c$p.value
            pvalcol[[as.character(f)]][sig] = cont_table[2,2] > cont_table[1,2]  
        }, error=function(e){})
    }
    
}
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
tmp = log10(pvalsig_df)
qs =  p.adjust(as.vector(pvalsig_df), method = "fdr")
qs = matrix(qs, nrow = nrow(pvalsig_df), ncol = ncol(pvalsig_df), byrow = F)
rownames(qs) = rownames(pvalsig_df)
colnames(qs) = colnames(pvalsig_df)
tmp = log10(qs)
tmp[tmp > log10(0.1)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_FDR10p.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(7), main = "ChiSq enrichement of Kait topic genes in each of David's factors")
dev.off()



```


(Which metadata is significantly enriched in a topic?)
https://willwerscheid.github.io/flashier/articles/flashier_closer_look.html#sampling-from-the-posterior
One of the list elements in the object returned by flash is a function that can sample from posterior distributions on loadings and factors. Take the backfit above as an example. To better understand which tissues are bound up with whole blood effects, we might like confidence intervals for the third factor. We construct 95% confidence intervals using 200 samples and then finding 2.5% and 97.5% quantiles as follows:
```{r}
# Set seed for reproducibility.
set.seed(1)
# Use returned sampler to sample from posterior.
samp = fit$sampler(nsamp = 200)
# Only keep factor 3.
factor_samp <- lapply(samp, function(x) x[[2]][, 10])
factor_samp[[1]]
# Normalize the loadings.
factor_samp <- sapply(factor_samp, function(x) x / max(abs(x)))
factor_samp[[1]]
# Get 95% confidence intervals.
factor_ci <- apply(factor_samp, 1, quantile, c(0.025, 0.975))

# Only keep factor 3.
factor_samp <- lapply(samp, function(x) x[[2]][, 10])
factor_samp[[1]]
# Normalize the loadings.
factor_samp <- sapply(factor_samp, function(x) x / max(abs(x)))
factor_samp[[1]]
# Get 95% confidence intervals.
factor_ci <- apply(factor_samp, 1, function(x) quantile(x, c(0.025, 0.975)))

plot(fit, 
     include_scree = F,
     include_pm = T,
     kset = 10,
     plot_type = "histogram",
     pm_which = "loadings", 
     pm_groups = so$organ_simplified,
     #bins = 20,
     pm_colors = mypal[1:length(unique(so$organ_simplified))]) +NoLegend() + geom_errorbar(aes(ymin = factor_ci[1, ], ymax = factor_ci[2, ]))

plot(fit, kset = 10, include_scree = FALSE) + geom_errorbar(aes(ymin = factor_ci[1, ], ymax = factor_ci[2, ]))
```

**Flashier second approach**
from Peter: The "second approach" we discussed is a two-stage approach: (1) use the subset of "spike-in" cells to first identify the batch effects, then (2) include these as factors in a flashier analysis of the full data. (To be safe, it may be better not to includ the spike-in cells in Step 2.) This second approach is a slightly more advanced usage of flashier and I'll put together a short script that illustrates how to do this.

example code
```{r}
library(flashier)
set.seed(1)
n <- 2000 #cells
m <- 4000 #genes
k <- 8

# Simulate the gene expression patterns: (i) baseline expression, (ii)
# three "batch effects", (iii) four "cell types". The first cell type
# will be used to estimate the two batch effects.
F <- matrix(0,m,k)
rownames(F) <- paste0("gene",1:m)
colnames(F) <- c("baseline","batch1","batch2","batch3",
                 "celltype1","celltype2","celltype3","celltype4")
F[,"baseline"] <- abs(rt(m,df = 4))
F[,"batch1"] <- rexp(m)
F[,"batch2"] <- rexp(m)
F[,"batch3"] <- rexp(m)
for (i in 1:4) {
  j <- which(runif(m) < 0.2)
  l <- paste0("celltype",i)
  F[j,l] <- rexp(length(j))
}

# Simulate the batch and cell-type memberships.
L <- matrix(0,n,k)
rownames(L) <- paste0("barcode",1:n)
colnames(L) <- c("baseline","batch1","batch2","batch3",
                 "celltype1","celltype2","celltype3","celltype4")
L[,"baseline"] <- runif(n)
batch <- factor(sample(3,n,replace = TRUE))
L[batch == 1,"batch1"] <- 1
L[batch == 2,"batch2"] <- 1
L[batch == 3,"batch3"] <- 1
celltype <- factor(sample(4,n,replace = TRUE))
for (i in 1:4)
  L[celltype == i,paste0("celltype",i)] <- 1

# Simulate the data matrix.
X <- tcrossprod(L,F) + rexp(n*m)
rownames(X) <- rownames(L)
colnames(X) <- rownames(F)

# Split the data into cell type 1 and the remaining cell types (cell
# types 2-4).
X1 <- X[celltype == 1,]
X2 <- X[celltype != 1,]

# Fit a flashier model to "spike-in" data (cell type 1). Note that in
# the flash_greedy call, it might be better to use ebnm_point_normal
# instead of ebnm_point_exponential.
fit1 <- flash(X1,ebnm_fn = ebnm_point_exponential,var_type = 0,S = 1/n, greedy_Kmax = 1)
fit1 <- flash_greedy(fit1, Kmax = 3, ebnm_point_exponential)
fit1 <- flash_backfit(fit1,extrapolate = FALSE,maxiter = 100)
posthoc_labels1 <- c("baseline","batch3","batch1","batch2")
colnames(fit1$F_pm) <- posthoc_labels1
colnames(fit1$L_pm) <- posthoc_labels1

# Some sanity checks.
print(round(cor(F,fit1$F_pm),digits = 3))
ks <- c("baseline","batch1","batch2","batch3")
print(round(cor(L[celltype == 1,ks],fit1$L_pm[,ks]),digits = 3))

# Fit a flashier model to the remaining data (cell types 2-4) in which
# the batch effects estimated from the "spike-in" data are
# incorporated into the model. This is a bit more complicated and
# involves several steps:
#
#   1. Add the "baseline" factor and set other parameters.
#      (flash)
#
#   2. Add factors for the 3 previously estimated batch effects.
#      (flash_factors_init)
#
#   3. Initialize 3 more factors to capture the cell types.
#      (flash_greedy)
#
#   4. Fix the batch effects. (flash_factors_fix)
#
#   5. Fit the free (non-fixed) parameters. (flash_backfit)
#
n    <- nrow(X2)
fit2 <- flash(X2,ebnm_point_exponential,var_type = 0,S = 1/n,greedy_Kmax = 1)
fit2 <- flash_factors_init(fit2,
                           list(matrix(0,n,3),fit1$F_pm[,-1]),
                           ebnm_point_exponential)
fit2 <- flash_greedy(fit2,Kmax = 3,ebnm_point_exponential)
fit2 <- flash_factors_fix(fit2,2:4,"factors")
fit2 <- flash_backfit(fit2,extrapolate = FALSE,maxiter = 200)
posthoc_labels2 <- c("baseline",
                     "batch3","batch1","batch2",
                     "celltype2","celltype4","celltype3")
colnames(fit2$F_pm) <- posthoc_labels2
colnames(fit2$L_pm) <- posthoc_labels2

# Some sanity checks.
print(round(cor(fit1$F_pm[,c("batch1","batch2","batch3")],
                fit2$F_pm[,c("batch1","batch2","batch3")]),
            digits = 3))
print(round(cor(F,fit2$F_pm),digits = 3))
ks <- c("baseline",
        "batch1","batch2","batch3",
        "celltype2","celltype3","celltype4")
print(round(cor(L[celltype != 1,ks],fit2$L_pm[,ks]),digits = 3))
pheatmap(round(cor(L[celltype != 1,ks],fit2$L_pm[,ks]),digits = 3))
```

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl_BatchRemoved"
ensure_directory(sprintf("%s/%s",prefix,prefix2))

fit = readRDS("flashier/20240718_knolim_pe_pl/fit.Rds") #50 topics, 2 batch topics (topic 2 and 3)

#calculate LDF on spleen only


#1. Add the "baseline" factor and set other parameters.
fit2 = flash(shifted_log_counts, 
             greedy_Kmax = 1,
             ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace),
             var_type = 2, 
             S = s1,
             backfit = FALSE)

#2. Add batch factors
fit2 = flash_factors_init(fit2,
                           list(matrix(0,nrow(shifted_log_counts),2),fit$F_pm[,c(2,3)]),
                           ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace))

#3. Find other factors
fit2 = flash_greedy(fit2,Kmax = 48,ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace))

#4. Fix batch effect topics
fit2 = flash_factors_fix(fit2,2:3,"factors") #fix the batch effect topics

#5. Fit the free (non-fixed) parameters. (flash_backfit)
fit2 = flash_backfit(fit2,extrapolate = FALSE, maxiter = 200)

saveRDS(fit2, file = sprintf("%s/%s/fit.Rds", prefix,prefix2))

```

















