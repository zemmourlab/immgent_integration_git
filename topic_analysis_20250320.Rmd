---
title: "topic_analysis"
output: html_document
date: "2024-04-30"
editor_options: 
  chunk_output_type: console
---

**Start interactive session on Midway3**
```{bash}
ssh -Y zemmour@midway3.rcc.uchicago.edu
sinfo -s
screen -S david
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=jfkfloor2 --qos=jfkfloor2 --nodes=1 
sinteractive --exclusive --time=12:00:00 --account=pi-zemmour --partition=zemmour-hm --qos=zemmour --nodes=1 
sinteractive --time=12:00:00 --account=pi-zemmour --partition=beagle3-bigmem --nodes=1 --mem=128GB
sinteractive --time=12:00:00 --account=pi-zemmour --partition=caslake --nodes=1 --mem=96GB
sinteractive --time=3:00:00 --account=pi-zemmour --partition=gpu --gres=gpu:1 --mem=152GB
cd $LABHOME

module load python/anaconda-2022.05 
module load hdf5/1.12.0 #for BPCells but also others
module load openblas/0.3.13

#sinteractive --time=1:00:00 -p gpu --gres=gpu:1 --account=pi-zemmour 

#source activate /project/jfkfloor2/zemmourlab/david/envs/scvi
source activate /project/zemmour/david/envs/scvi_20240315
module load openblas/0.3.13 #load again or error

cd /project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/
#cd ~/google_drive/ImmgenT/analysis/data_integration/IGT1_56/Treg

#srun --pty --jobid 21908677 -w midway3-0291 /bin/bash

R
#options(max.print=1000)
#options(Seurat.object.assay.version = 'v5')
```

**Initialize in R: load libraries and custom functions**

```{r}
options(max.print=1000)
# setwd("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_96")
# source("/project/jfkfloor2/zemmourlab/david/immgent/immgent_integration_git/custom_functions_david.R")

libs = c("ZemmourLib","fgsea","fastTopics", "flashier", "Matrix", "Seurat","BPCells", "ggplot2","scattermore", "dplyr", "reshape2", "ggrastr", "RColorBrewer", "pals", "scales", "pheatmap", "rafalib", "limma") 
#libs = c("matrixStats", "gplots","ggplot2", "reshape2", "scales", "gridExtra", "dplyr", "RColorBrewer", "grid", "Rtsne", "limma",   "RColorBrewer", "pheatmap", "Seurat",  "ggrastr", "ggbeeswarm") #pwr, preprocessCore, "readxl", vegan", "genefilter" "scde" "cellrangerRkit", "Rsamtools", "GenomicRanges", "GenomicAlignments", "VGAM", "WGCNA",rafalib, ‘UsingR’,MAST "ggrastr",
sapply(libs, function(x) suppressMessages(suppressWarnings(library(x, character.only = TRUE, quietly = T, warn.conflicts  = F))))


#Gradients
library(RColorBrewer)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdYlBu"))(100))
# ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = rev(rainbow(10, end = 4/6))
library(viridis)
ColorRamp = rev(viridis(100))
ColorRamp = rev(cividis(100))
ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
ColorRamp = colorRampPalette(c('white','red'))(20)
ColorRamp = rev(colorRampPalette(brewer.pal(n = 7,name = "RdBu"))(100))
# ColorRamp = colorRampPalette(c('Red'))(20)
#image(1:100, 1, as.matrix(1:100), col = ColorRamp, main = "Color Palette", xaxt = 'n', yaxt = 'n', xlab = "", ylab = "")

#mycol = c("black","blue","red","darkgreen", "orange","purple", "cyan", "greenyellow",    "salmon", "magenta","pink", "tan", "brown") # c("magenta", "red",  "darkgreen", "cyan", "blue", "blue", "blue", "black", "blue", "blue", "blue", "blue", "orange")

#Large Color palette
library("pals")
n = 70
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
mypal1 = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
mypal1 = mypal1[-4]
mypal = c(glasbey(), polychrome(), mypal1)
names(mypal) = NULL

mypal_organ = immgent_colors$organ_simplified
mypal_level1 = immgent_colors$level1
mypal_level2 = immgent_colors$level2

#pal.bands(mypal, main="Colormap suggestions")
# mypal_organ = setNames(mypal, unique(so$organ_simplified))
# mypal_organ = mypal_organ[!is.na(names(mypal_organ))]
# mypal_level1 = setNames(mypal, unique(so$annotation_level1))
# mypal_level1 = mypal_level1[!is.na(names(mypal_level1))]
# mypal_level2 = setNames(mypal, unique(so_orig$annotation_level2))
# mypal_level2 = mypal_level2[!is.na(names(mypal_level2))]
# mypal_level2["CD4_cl18"] = "blue"
mypal_igt = setNames(mypal, unique(so$IGT))
mypal_igt = mypal_igt[!is.na(names(mypal_igt))]


#parade = function(n) { return(Seurat::DiscretePalette(n, palette = "parade", shuffle = F)) }
```

**Flashier**
https://willwerscheid.github.io/flashier/articles/flashier_intro.html

```{r}
# so_orig = readRDS(file = "igt1_96_withtotalvi20250317_clean.Rds")
# so_orig = readRDS(file = "igt1_96_withtotalvi20250513_clean.Rds")
so_orig = readRDS(file = "igt1_96_withtotalvi20250710_clean.Rds")
so_orig$annotation_level2[so_orig$annotation_level2 == "Treg_cl7"] = "Treg_cl1"

so_orig = readRDS(file = "igt1_96_withtotalvi20260107_clean.Rds")


sampled_cellID = read.table("/project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/igt1_96_sampledcells200K.csv", header = F, as.is = T)[,1]
# sampled_cellID %>% write.table("igt1_96_sampledcells200K.csv", quote = F, row.names = F, col.names = F, sep = ",")
# so1 = readRDS(file = "DGE_limma/20250109/igt1_96_withtotalvi20250109_clean_sampled.Rds")
# sampled_cellID = sampled_cellID[!sampled_cellID %in% colnames(so1)[so1$annotation_level2 == "gdT_53"]]

```

flashier20250215_alldata_backfit -- all cells data + backfit + K=200


*Plots for flashier object*
```{r}
so_orig$annotation_level2[so_orig$annotation_level2 == "Treg_cl7"] = "Treg_cl1"
prefix = "topic"
prefix2 = "flashier20250215_alldata_backfit"
fit_flash = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))
fit = fit_flash
all(rownames(fit$L_pm) == colnames(so))

```

scree_plot.pdf
```{r}
pdf(sprintf("%s/%s/scree_plot.pdf", prefix, prefix2), 10, 5, useDingbats = F)
plot(fit, plot_type = "scree")
dev.off()

data.frame(factor = sprintf("F%s", 1:ncol(fit$F_pm)), pve = fit$pve) %>% write.table(sprintf("%s/%s/factor_pve.txt", prefix, prefix2), quote = F, sep = "\t", row.names = F, col.names = T)
sum(fit$pve)
order(fit$pve, decreasing = T)
```

histogram_loadings_plot.pdf
```{r}
pdf(sprintf("%s/%s/histogram_loadings_plot.pdf", prefix, prefix2), 40, 40, useDingbats = F)
plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_groups = so$organ_simplified,
     bins = 20,
     pm_colors = mypal_organ) #+ NoLegend()
     # pm_colors = mypal[1:length(unique(so$organ_simplified))]) #+ NoLegend()

plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_groups = so$annotation_level1,
     bins = 20,
     pm_colors = mypal_level1) #+ NoLegend()
     # pm_colors = mypal[1:length(unique(so$organ_simplified))]) #+ NoLegend()

plot(fit,
     # include_scree = F,
     # include_pm = T,
     plot_type = "histogram",
     pm_which = "loadings",
     pm_subset = spl_cells,
     pm_groups = so$IGT[so$spleen_standard],
     bins = 20,
     pm_colors = mypal_igt[unique(so$IGT[so$spleen_standard])]) + #mypal[1:length(unique(so$IGT[so$spleen_standard]))]
    ggtitle("Spleen standard only")#+ NoLegend()

dev.off()

pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20, 8, useDingbats = F)
plot(fit,
     plot_type = "structure",
     pm_which = "loadings",
     pm_groups = so$organ_simplified,
     pm_colors = mypal,
     gap = 25) #+ NoLegend()

plot(fit,
     include_scree = F,
     plot_type = "structure",
     pm_which = "loadings",
     pm_groups = so$annotation_level1,
     pm_colors = mypal,
     gap = 25) #+ NoLegend()

plot(fit,
     plot_type = "structure",
     pm_which = "loadings",
     pm_subset = spl_cells,
     pm_groups = so$IGT[so$spleen_standard],
     pm_colors = mypal,
     gap = 25)
dev.off()


```

factors_volcano.pdf
factors_heatmap.pdf
de_genes_factors.txt
```{r}
message("factors_volcano.pdf")
res = ldf(fit, type = "i")
F1 = with(res, F %*% diag(D)) #same as res$F %*% diag(res$D)
# rownames(F1) = colnames(shifted_log_counts)
head(sort(F1[,6], decreasing = TRUE), n = 16)
colnames(F1) = sprintf("F%s", 1:ncol(F1))
F1 = F1[,order(fit$pve, decreasing = T)]
F1 %>% write.table(sprintf("%s/%s/de_genes_factors.txt", prefix, prefix2), quote = F, sep = "\t", row.names = T, col.names = T)
genes = apply(F1, 2, order, decreasing = TRUE)[1:10, 2:fit$n_factors]
top_genes = rownames(F1)[genes]
top_genes_m  = matrix(rownames(F1)[genes], nrow = nrow(genes), byrow = TRUE)

pdf(sprintf("%s/%s/factors_volcano.pdf", prefix, prefix2), 5, 5, useDingbats = F)
for (i in 1:fit$n_factors) {
    print(i)
    p = plot(fit,
             include_scree = F,
             plot_type = "scatter",
             pm_which = "factors",
             kset = i,
             labels = T,
             n_labels = 50,
             label_size = 2.5) +
        labs(x = "increase in shifted log expression",
             y = "mean shifted log expression") +
        ggtitle(sprintf("k = %s",i))
    print(p)
}
dev.off()

message("factors_heatmap.pdf")
pdf(sprintf("%s/%s/factors_heatmap.pdf", prefix, prefix2), 10,40, useDingbats = F)
tmp3 = F1[top_genes,]
tmp3[tmp3>3] = 3
tmp3[tmp3 < -3] = -3
# ColorRamp = viridis(100)
colnames(tmp3) = sprintf("factor%s", 1:ncol(F1))
pheatmap(mat = tmp3, cluster_rows = F, cluster_cols = F, col = ColorRamp, fontsize_row = 1, fontsize_col = 1,  main = "FC in top 20 genes in topics")
dev.off()


```

**L1**

```{r}

L1 = with(ldf(fit, type = "i"), L %*% diag(D)) #same as res$F %*% diag(res$D)
# L1 = with(ldf(fit, type = "i"), L) 
# L1 = with(ldf(fit, type = "i"), L) 
# rownames(F1) = colnames(shifted_log_counts)
# head(sort(F1[,6], decreasing = TRUE), n = 16)
colnames(L1) = sprintf("F%s", 1:ncol(L1))

all(rownames(L1) == colnames(so))
L1 = L1[colnames(so),]
all(rownames(L1) == colnames(so))

mdata_orig = data.frame(so@meta.data,L1)
# shist(mdata_orig$F1)
# max(mdata_orig[mdata_orig$spleen_standard == T,grepl("^F",colnames(mdata_orig))])
# mdata_orig %>% write.table(file = sprintf("%s/%s/loadings_withmetadata.tsv", prefix, prefix2), quote = F, row.names = F, col.names = T, sep = "\t")

#for Laurent
# tmp = so[,rownames(L1)]
# L1 = L1[colnames(tmp),]
# mdata_orig = data.frame(tmp@meta.data,L1)
# mdata_orig %>% write.table(file = sprintf("%s/%s/loadings_withmetadata.tsv", prefix, prefix2), quote = F, row.names = F, col.names = T, sep = "\t")

```

#162 has Il22
```{r}

plot(L1[,1], L1[,162], pch = ".", log = "x"  )
```

Average topic per annotation_level2
```{r}
fit$pve > 10^-4
mdata = data.frame(so@meta.data %>% select(annotation_level2),L1[,fit$pve > 10^-4])

library(dplyr)
library(tibble)
library(pheatmap)

# 1) Mean of each factor per cluster
means_df <- mdata %>%
  group_by(annotation_level2) %>%
  summarise(across(starts_with("F"), ~mean(.x, na.rm = TRUE)), .groups = "drop")

# 2) Convert to matrix: rows = factors, cols = clusters
mat <- means_df %>%
  column_to_rownames("annotation_level2") %>%  # now rows are clusters
  as.matrix()

mat <- t(mat)  # now rows = F1..Fn, cols = clusters

# 3) Heatmap
pheatmap(
  mat,
  scale = "row",
  cluster_rows = F,
  cluster_cols = F,
  border_color = NA
)

ColorRamp = rev(colorRampPalette(c('red','white','blue'))(20))
mat_centered <- sweep(mat, 1, rowMeans(mat, na.rm = TRUE), "-")
pheatmap(mat_centered, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = F, main = "fit2$coefficients fit_flash$pve > 10^-4 | rowSums(abs(fit2$coefficients) > 0.5) > 1")



```


**Flagging batch specific topics **
9, 49, 171
Limma with spleen control
```{r}
library(limma)
mdata = mdata_orig[mdata_orig$spleen_standard == T,]
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

pdf(sprintf("%s/%s/spleenctrl_factors_boxplots.pdf", prefix, prefix2), 20,10, useDingbats = F)
for (i in colnames(mdata)[grepl("^F",colnames(mdata))]) {
    print(i)
    p = ggplot(mdata[mdata$spleen_standard == T,], aes(IGT, !!sym(i))) + 
        geom_boxplot(aes(fill = IGT, group = IGT) ) + 
        # ylim(0,ceiling(max(mdata[mdata$spleen_standard == T,grepl("^F",colnames(mdata))]))) +
        scale_fill_manual(values = mypal_igt) + theme_bw() + 
        ggtitle(label = sprintf("%s", i)) # + theme_bw()+ ggtitle(label = "F1 IGT") + theme(axis.text.x  = element_text(angle=75, vjust=0.5, size=10)
    print(p)
}
dev.off()

#limma model
# factor_means = mdata %>% filter(mdata$spleen_standard == T) %>% group_by(IGT) %>% summarize_at(vars(matches("^F")), mean) %>% as.data.frame()
# factor_means = factor_means[order(extract_numeric(factor_means$IGT)),]
# rownames(factor_means) = factor_means$IGT
# factor_means = factor_means[,-1]
# factor_means = t(factor_means)


# Create the design matrix for the linear model
design = model.matrix(~ 0 + IGT, data = mdata[mdata$spleen_standard == T,])
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[mdata$spleen_standard == T, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# Apply empirical Bayes moderation
fit2 = eBayes(fit)
# Extract p-values for all comparisons
adj_pvalues = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH")

pvmat = adj_pvalues
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/spleenctrl_factors_heatmap.pdf", prefix, prefix2), 20,20, useDingbats = F)
# pheatmap(factor_means, cluster_rows = F, cluster_cols = F, display_numbers = labels_matrix, main = "mean from LD")
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()

```

**Limma with annotation level1: ~ 0 + annotation_level1 + IGTHT**

all cells ~ 0 + annotation_level1 + IGTHT
```{r}
prefix3 = "limma/20250320_level1_IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGTHT, data = mdata)
colnames(design) = gsub("annotation_level1|IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

sampled cells ~ 0 + annotation_level1 + IGTHT
```{r}
prefix3 = "limma/20250320_level1_IGTHT_sampled"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig[sampled_cellID,]
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGTHT, data = mdata)
colnames(design) = gsub("annotation_level1|IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

all cells ~ 0 + annotation_level1 + IGT
```{r}
prefix3 = "limma/20250323_level1_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])
mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level1 + IGT, data = mdata)
colnames(design) = gsub("annotation_level1", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level1, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1)) {
    print(cl)
    group1_filter <- expr(annotation_level1 == cl)
    group2_filter <- expr(!(annotation_level1 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 10,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(cont.matrix)) {
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

**Treg topics**
Load L1 and F1
```{r}
fig_dir = "~/google_drive_uchicago/ImmgenT/20250109_freeze/Treg/paper_Treg/figures/bits_david"
fig_dir = "/project/zemmour/david/ImmgenT/analysis/data_integration/IGT1_96/Treg/paper_Treg/figures/bits_david"

res = ldf(fit, type = "i")
L1 = with(res, L %*% diag(D)  ) #same as res$L %*% diag(res$D)
L1 = L1[colnames(so_orig),]
all(colnames(so_orig) == rownames(L1))
any(is.na(L1))
colnames(L1) = sprintf("F%s", 1:ncol(L1))
# sub_cells = sample(colnames(so_orig), 1500, replace = F)
# sub_cells = c(sample(colnames(so_orig)[so_orig$annotation_level1 %in% "Treg"], 1500, replace = F), sample(colnames(so_orig)[!so_orig$annotation_level1 %in% "Treg"], 1500, replace = F))
# sub_cells = c(so_orig@meta.data %>% filter(annotation_level1 == "Treg") %>% slice_sample(n = 1500, replace = FALSE) %>% pull(cellID),
#               so_orig@meta.data %>% filter(annotation_level1 != "Treg") %>% group_by(annotation_level1) %>% slice_sample(n = 100, replace = FALSE) %>% ungroup() %>% pull(cellID))

F1 = with(ldf(fit, type = "i"), F)
colnames(F1) = paste("F", 1:ncol(F1), sep = "")
```

F27+F68
```{r}
pdf(file = sprintf("%s/StructurePlot_F27F68.pdf", fig_dir), 10, 5, useDingbats = F)
sub_cells = c(so_orig@meta.data %>% filter(annotation_level1 == "Treg") %>% slice_sample(n = 1500, replace = FALSE) %>% pull(cellID),
              so_orig@meta.data %>% filter(annotation_level1 != "Treg") %>% group_by(annotation_level1) %>% slice_sample(n = 100, replace = FALSE) %>% ungroup() %>% pull(cellID))
structure_plot(L1[sub_cells,], topics = c(27,68), gap = 25, colors = mypal_topics,loadings_order = sub_cells,grouping = so_orig$annotation_level1[sub_cells]) + ylim(values = c(0,5))
ZemmourLib::MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level1[sub_cells], topics = c("F68"), colors = mypal_topics, y_limit = c(0, 4), bar_width = 4)
ZemmourLib::MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level1[sub_cells], topics = c("F27"), colors = mypal_topics, y_limit = c(0, 4), bar_width = 4)

sub_cells = c(so_orig@meta.data %>% filter(annotation_level1 == "Treg") %>% group_by(annotation_level2) %>% slice_sample(n = 500, replace = FALSE) %>% ungroup() %>% pull(cellID))
structure_plot(L1[sub_cells,], topics = c(27,68), colors = mypal_topics, gap = 25, loadings_order = sub_cells,grouping = so_orig$annotation_level2[sub_cells]) + ylim(values = c(0,5))
dev.off()

#############

#' Creates a structured bar plot for topic expression across cell groups.
#'
#' @param loadings_matrix A matrix or data frame where rows are cells and columns are topics. Rownames must be cell IDs.
#' @param grouping_vector A vector with group assignments for each cell, in the same order as the rows in loadings_matrix.
#' @param topics A character vector of the topic column names to include in the plot.
#' @param colors A named vector of colors for the topics.
#' @param y_limit A numeric vector of length 2 for the y-axis limits, e.g., c(0, 4).
#' @return A ggplot object.
MyStructurePlot <- function(loadings_matrix, grouping, topics, colors = mypal_topics, y_limit = c(0, 4), bar_width = 1) {
    
    # --- 1. Combine inputs into a single data frame ---
    plot_data <- as.data.frame(loadings_matrix) %>%
        rownames_to_column(var = "cellID") %>%
        mutate(grouping = grouping)
    
    # --- 2. Reshape and prepare data for plotting ---
    # pivot_longer(
    #   cols = -c(cellID, grouping),
    #   names_to = "variable",
    #   values_to = "value"
    # ) %>%
    # filter(variable %in% topics) %>%
    # arrange(grouping, desc(value)) %>%
    # mutate(cellID = factor(cellID, levels = unique(cellID)))
    
    plot_data = melt(plot_data)
    plot_data = plot_data[plot_data$variable %in% topics,]
    
    # --- 3. Create the Plot ---
    p <- ggplot(plot_data, aes(x = cellID, y = value, fill = variable)) +
        geom_col(width = bar_width) +
        facet_grid(. ~ grouping,
                   scales = "free_x",
                   space  = "free_x") +
        scale_fill_manual(values = colors) +
        coord_cartesian(ylim = y_limit) +
        theme_minimal() +
        theme(
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            strip.placement = "bottom", # This moves the facet labels to the bottom
            strip.background = element_blank(),
            strip.text.x = element_text(face = "bold", size = 10),
            panel.spacing.x = unit(0.5, "cm"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(),
            panel.border = element_blank(),
            plot.title = element_text(hjust = 0.5, face = "bold"),
            axis.title.x = element_blank(),
            axis.title.y = element_text(size = 10, face = "bold")
        ) +
        NoGrid() +
        labs(
            title = "",
            y = "Topic Expression",
            fill = "Topic"
        )
    
    return(p)
}

# MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level1[sub_cells], topics = c("F68"), colors = mypal_topics, y_limit = c(0, 4))
# MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level1[sub_cells], topics = c("F27"), colors = mypal_topics, y_limit = c(0, 4))



# topic_colors = mypal[1:ncol(fit$L_pm)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")
# topic_colors = rep(mypal, length.out = ncol(fit$L_pm))


# Define your custom color palette (if desired)
# custom_colors = c("F27" = "red", "F68" = "blue")

pdf(file = sprintf("%s/StructurePlot_F68.pdf", fig_dir), 10, 5, useDingbats = F)
sub_cells = c(so_orig@meta.data %>% filter(annotation_level1 == "Treg") %>% slice_sample(n = 1500, replace = FALSE) %>% pull(cellID),
              so_orig@meta.data %>% filter(annotation_level1 != "Treg") %>% group_by(annotation_level1) %>% slice_sample(n = 100, replace = FALSE) %>% ungroup() %>% pull(cellID))

df = data.frame(L1[sub_cells,], grouping = so_orig$annotation_level1[sub_cells], cellID = sub_cells)
topics = c("F68")
plot_data = melt(df)
plot_data = plot_data[plot_data$variable %in% topics,]


p = ggplot(plot_data, aes(x = cellID,y = value, fill = variable)) +
  geom_col(width = 1) + # width = 1 ensures no internal gaps between bars within a group
  
  # Facet by cell_group, with free x-scales and space for gaps between groups
  facet_grid(. ~ grouping,
             scales = "free_x",
             space = "free_x") +
  
  # Custom colors
  scale_fill_manual(values = mypal_topics) +
  
  # Clean up the theme
  theme_minimal() +
    ylim(values = c(0,4))+
  theme(
    # Rotate x-axis labels to prevent overlap (if many subtypes)
    axis.text.x =  element_blank(),
    
    # Remove extra space/ticks on the x-axis where facets meet
    axis.ticks.x = element_blank(),
    
    # Remove the background of the facet strips
    strip.background = element_blank(),
    
    # Make facet titles bold
    strip.text.x = element_text(face = "bold", size = 10),
    
    # Control the spacing between facets (creating the visible gap)
    panel.spacing.x = unit(0.5, "cm"), # Adjust this for desired gap size
    
    # Remove grid lines for a cleaner look if desired
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    # panel.grid.major.y = element_blank(),
    # panel.grid.minor.y = element_blank(),
    
    # Optionally remove plot border
    panel.border = element_blank(),
    
    # Adjust overall plot title/labels
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.x = element_blank(), # Remove x-axis title as facet labels are clear
    axis.title.y = element_text(size = 10, face = "bold")
  ) +
    NoGrid() +
  labs(
    title = "",
    y = "Topic Expression",
    fill = "Topic" # Legend title
  )
p




```

Gene tile plot
```{r}
pdf(file = sprintf("%s/GeneTilePlot_F27F68.pdf", fig_dir), 5, 5, useDingbats = F)
ZemmourLib::MyGeneTilePlot(gene_factor_matrix = F1, topics = c("F68", "F27"), n_genes_per_topic = 15, title = "Genes in GP")

ZemmourLib::MyGeneTilePlot(gene_factor_matrix = F1, topics = c("F68"), n_genes_per_topic = 15, title = "Genes in GP")
ZemmourLib::MyGeneTilePlot(gene_factor_matrix = F1, topics = c("F68"), n_genes_per_topic = 15,alpha_range = c(0,1), title = "Genes in GP")
dev.off()

#############
# Load necessary libraries
library(tidyverse)
library(reshape2) # For melt, though pivot_longer is used

#' Create a tile plot of top gene expression for specified topics.
#'
#' @param gene_factor_matrix A matrix with genes as rows and topics as columns. Rownames must be gene names.
#' @param topics A character vector of the topic column names to plot.
#' @param n_genes_per_topic The number of top genes to select from each topic.
#' @param title A character vector of the title of the plot
#' @param alpha_range A numeric vector of the range of values of expression to apply alpha. Default NULL is determined automatically
#' @return A ggplot object.
MyGeneTilePlot <- function(gene_factor_matrix = F1,
                           topics = c("F68", "F27"),
                           n_genes_per_topic = 15,
                           alpha_range = NULL,
                           title = "Dot Plot (Squares) of Gene Expression") {
    # Dependencies
    if (!requireNamespace("ggplot2", quietly = TRUE)) stop("Please install.packages('ggplot2')")
    if (!requireNamespace("reshape2", quietly = TRUE)) stop("Please install.packages('reshape2')")
    
    F1 = gene_factor_matrix
    # Safety checks
    if (is.null(colnames(F1))) stop("F1 must have column names (topic names).")
    if (is.null(rownames(F1))) stop("F1 must have rownames (gene names).")
    missing_topics <- setdiff(topics, colnames(F1))
    if (length(missing_topics)) stop(sprintf("These topics are not in F1: %s", paste(missing_topics, collapse = ", ")))
    
    # Get top genes per topic (indices), then unique gene names
    idx_mat <- apply(F1[, topics, drop = FALSE], 2, function(col)
        head(order(col, decreasing = TRUE), n_genes_per_topic)
    )
    # idx_mat can be vector if length(topics)==1
    idx_vec <- unique(as.vector(idx_mat))
    top_genes <- rownames(F1)[idx_vec]
    
    # Build plotting data
    F_sub <- F1[top_genes, topics, drop = FALSE]
    plot_data <- reshape2::melt(F_sub, varnames = c("Gene", "Factor"), value.name = "Expression")
    plot_data$Factor <- factor(plot_data$Factor, levels = topics)
    
    # Ensure genes appear ordered by first topic (highest to lowest), like your original reverse scale
    ordering_topic <- topics[1]
    gene_order <- names(sort(F1[top_genes, ordering_topic], decreasing = TRUE))
    plot_data$Gene <- factor(plot_data$Gene, levels = rev(gene_order))
    
    # Plot
    # if (do_alpha) {
    #     p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = Factor, y = Gene, fill = Expression, alpha = Expression))
    # } else {
    #     p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = Factor, y = Gene, fill = Expression))
    # }
    p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = Factor, y = Gene, fill = Expression, alpha = Expression)) +
        ggplot2::geom_tile(width = 0.9, height = 0.9) +
        ggplot2::scale_fill_gradient(low = "white", high = "brown", limits = c(0, NA), na.value = "white")
    if (!is.null(alpha_range)) {
        p = p + scale_alpha_continuous(limits = alpha_range)
    }
    
    p = p + 
        ggplot2::theme_minimal() +
        ggplot2::theme(
            axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
            panel.grid = ggplot2::element_blank(),
            panel.border = ggplot2::element_blank()
        ) +
        ggplot2::coord_fixed(ratio = 1) +
        NoGrid() +
        ggplot2::labs(title = title, x = "", y = "", fill = "Expression (Color)", alpha = "Expression (alpha)")
    
    return(p)
}


top_genes = apply(F1, 2, order, decreasing = TRUE)[1:15, c("F68", "F27")]
# top_genes = unique(c("Ifng",rownames(fit$F_pm)[top_genes]))
top_genes

plot_data = melt(F1[top_genes,c("F68","F27")], varnames = c("Gene", "Factor"), value.name = "Expression")
plot_data$Factor = factor(plot_data$Factor, levels = c("F68","F27"))

# Create the dot plot

pdf(sprintf("%s/GeneTileF27F68.pdf", fig_dir), 3, 7, useDingbats = F)
p = ggplot(plot_data, aes(x = Factor, y = Gene, fill = Expression, alpha = Expression)) +
  geom_tile(width = 0.9, height = 0.9) +  # Adjust the width and height for the gaps
  scale_fill_gradient(low = "white", high = "brown",limits = c(0, NA), na.value = "white") +# Adjust color gradient
    # scale_alpha(range = c(0, 1)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    panel.grid = element_blank(),  # Remove gridlines
    panel.border = element_blank()  # Optional: remove the border around the plot
  ) +
    scale_y_discrete(limits = rev(levels(plot_data$Gene))) + 
  coord_fixed(ratio = 1) +  # Ensure tiles are square
  labs(title = "Dot Plot (Squares) of Gene Expression", x = "Layer", y = "Gene",
       fill = "Expression (Color)",
       alpha = "Expression (alpha)",)
print(p)
# dev.off()


####Just F68
top_genes = apply(F1, 2, order, decreasing = TRUE)[1:15, c("F68")]
top_genes

plot_data = melt(F1[top_genes,c("F68")], varnames = c("Gene", "Factor"), value.name = "Expression")
plot_data$Factor = "F68"#factor(plot_data$Factor, levels = c("F68"))
plot_data$Gene = factor(rownames(plot_data), levels = rownames(plot_data))

# pdf(sprintf("%s/GeneTileF27F68.pdf", fig_dir), 3, 7, useDingbats = F)
p = ggplot(plot_data, aes(x = Factor, y = Gene, fill = Expression)) +
  geom_tile(width = 0.9, height = 0.9) +  # Adjust the width and height for the gaps
  scale_fill_gradient(low = "white", high = "brown",limits = c(0, NA), na.value = "white" ) +  # Adjust color gradient
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    panel.grid = element_blank(),  # Remove gridlines
    panel.border = element_blank()  # Optional: remove the border around the plot
  ) +
    scale_y_discrete(limits = rev(levels(plot_data$Gene))) + 
  coord_fixed(ratio = 1) +  # Ensure tiles are square
  labs(title = "Dot Plot (Squares) of Gene Expression", x = "Layer", y = "Gene")
print(p)
dev.off()
```

Activated Treg topics

F27 for all eff
F12 for cl3
F6 for 2/8
F80 for cl4
F15 for cl6
F174 for cl6
F152 for cl8
F5 for prolif
```{r}
sub_cells = c(so_orig@meta.data %>% filter(annotation_level1 == "Treg" & !(annotation_level2 %in% c("Treg_miniverse", "Treg_prolif"))) %>% group_by(annotation_level2) %>% slice_sample(n = 500, replace = FALSE) %>% ungroup() %>% pull(cellID))
mypal_topics = setNames(object = RColorBrewer::brewer.pal(8,name = "Set1"), c("F27","F12", "F6", "F80", "F15", "F152")) #RColorBrewer::brewer.pal(8,name = "Accent") sample(gtex_colors)
mypal_topics = mypal_topics[!is.na(names(mypal_topics))]

pdf(file = sprintf("%s/StructurePlot_ActTregGP.pdf", fig_dir), 10, 5, useDingbats = F)
structure_plot(L1[sub_cells,rev(c("F27","F12", "F15", "F152","F6", "F80"))], topics = rev(c("F27","F12", "F15", "F152","F6", "F80")), colors = mypal_topics, gap = 25, loadings_order = sub_cells,grouping = so_orig$annotation_level2[sub_cells]) + ylim(values = c(0,10)) #
structure_plot(L1[sub_cells,rev(c("F27","F12", "F15", "F152","F6", "F80"))], topics = rev(c("F27","F12", "F15", "F152","F6", "F80")), colors = mypal_topics, gap = 25,loadings_order = "embed", grouping = factor(so_orig$annotation_level2[sub_cells])) + ylim(values = c(0,10)) 
# structure_plot(L1[sub_cells,], topics = c("F27","F12", "F6", "F80", "F15", "F152"), gap = 25, n = 1000,grouping = so_orig$annotation_level2[sub_cells])
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = rev(c("F27","F12", "F15", "F152","F6", "F80")), colors = mypal_topics, y_limit = c(0, 10), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F27"), colors = mypal_topics, y_limit = c(0, 2.5), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F12"), colors = mypal_topics, y_limit = c(0, 2.5), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F15"), colors = mypal_topics, y_limit = c(0, 2.5), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F152"), colors = mypal_topics, y_limit = c(0, 2.5), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F6"), colors = mypal_topics, y_limit = c(0, 3), bar_width = 2)
MyStructurePlot(loadings_matrix = L1[sub_cells,], grouping = so_orig$annotation_level2[sub_cells], topics = c("F80"), colors = mypal_topics, y_limit = c(0, 2.5), bar_width = 2)
dev.off()

##GeneTile plot
pdf(file = sprintf("%s/GeneTilePlot_ActTregG.pdf", fig_dir), 5, 10, useDingbats = F)
MyGeneTilePlot(gene_factor_matrix = F1, topics = c("F27","F12", "F15", "F152","F6", "F80"), n_genes_per_topic = 15,alpha_range = c(0,1), title = "Genes in GP")
MyGeneTilePlot(gene_factor_matrix = F1, topics = c("F27","F12", "F15", "F152","F6", "F80"), n_genes_per_topic = 15, title = "Genes in GP")
dev.off()

###DotPlot of classic genes in association with GP
idx_mat <- apply(F1[,c("F27","F12", "F15", "F152","F6", "F80")], 2, function(col) head(order(col, decreasing = TRUE), 15))
idx_vec <- as.vector(idx_mat)
idx_vec <- unique(as.vector(idx_mat))
top_genes <- rownames(F1)[idx_vec]

so = so_orig[,sub_cells] %>% NormalizeData()

pdf(file = sprintf("%s/DotPlot_ActTregG.pdf", fig_dir), 20, 5, useDingbats = F)
DotPlot(object = so, top_genes, assay = "RNA", group.by = "annotation_level2")  + scale_colour_gradientn(colours =  rev(magma(10))) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
DotPlot(object = so, top_genes, assay = "RNA", group.by = "annotation_level2") + scale_colour_gradientn(colours =  colorRampPalette(c('white','red'))(20)) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
DotPlot(object = so, top_genes, assay = "RNA", group.by = "annotation_level2") + scale_colour_gradientn(colours =  rev(colorRampPalette(brewer.pal(n = 7,name = "RdBu"))(20))) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
dev.off() 

idx_mat <- apply(F1[,c("F27","F12", "F15", "F152","F6", "F80")], 2, function(col) head(order(col, decreasing = TRUE), 15))
p = list()
for (topic in c("F27","F12", "F15", "F152","F6", "F80")) {
    print(topic)
    idx_vec <- as.vector(idx_mat[,topic])
    top_genes <- rownames(F1)[idx_vec]
    # p[[topic]] = DotPlot(object = so, top_genes, assay = "RNA", group.by = "annotation_level2", dot.scale = 6, scale = T, scale.by = "radius")  + 
    #     labs(y = topic, x = NULL) +
    #     scale_colour_gradientn(colours =  colorRampPalette(c('white',mypal_topics[topic]))(10)) + 
    #     theme(axis.text.x = element_text(angle = 45, hjust = 1)) + coord_flip()
    p[[topic]] = MyDotPlot(object = so, top_genes, assay = "RNA", group.by = "annotation_level2", dot.scale = 6, scale = T, scale.by = "radius",point.shape = 21, alpha.range = c(0, 1), show.alpha.legend = F)  + 
    labs(y = topic, x = NULL) +
    scale_fill_gradientn(colours =  colorRampPalette(c("grey",'white',mypal_topics[topic]))(10)) + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + coord_flip()

}

stacked = wrap_plots(p, ncol = 1) + plot_layout(axes = "collect_x", guides = "collect")  # collect x-axes & legends
pdf(file = sprintf("%s/GeneTilePlot_ActTregG_stacked.pdf", fig_dir), 5, 18, useDingbats = F)
stacked
dev.off()


MyDotPlot <- function (
        object, features, assay = NULL,
        cols = c("lightgrey","blue"), col.min = -2.5, col.max = 2.5,
        dot.min = 0, dot.scale = 6, idents = NULL, group.by = NULL,
        split.by = NULL, cluster.idents = FALSE, scale = TRUE,
        scale.by = "radius", scale.min = NA, scale.max = NA,
        point.shape = 21,                 # 21 has fill + outline
        alpha.range = c(0.2, 1.0),
        show.alpha.legend = FALSE
) {
    if (!requireNamespace("ggplot2", quietly = TRUE)) stop("Install ggplot2")
    if (!requireNamespace("rlang", quietly = TRUE)) stop("Install rlang")
    
    `%||%` <- Seurat::`%||%`
    assay <- assay %||% Seurat::DefaultAssay(object)
    Seurat::DefaultAssay(object) <- assay
    
    split.colors <- !is.null(split.by) && !any(cols %in% rownames(RColorBrewer::brewer.pal.info))
    scale.func <- switch(scale.by,
                         size   = ggplot2::scale_size,
                         radius = ggplot2::scale_radius,
                         stop("'scale.by' must be either 'size' or 'radius'"))
    
    feature.groups <- NULL
    if (is.list(features) || any(!is.na(names(features)))) {
        feature.groups <- unlist(lapply(seq_along(features), function(i) rep(names(features)[i], length(features[[i]]))))
        if (any(is.na(feature.groups))) warning("Some feature groups are unnamed.", call. = FALSE, immediate. = TRUE)
        features <- unlist(features)
        names(feature.groups) <- features
    }
    
    cells <- unlist(Seurat::CellsByIdentities(object, cells = colnames(object[[assay]]), idents = idents))
    data.features <- Seurat::FetchData(object, vars = features, cells = cells)
    
    data.features$id <- if (is.null(group.by)) Seurat::Idents(object)[cells, drop = TRUE] else object[[group.by, drop = TRUE]][cells, drop = TRUE]
    if (!is.factor(data.features$id)) data.features$id <- factor(data.features$id)
    id.levels <- levels(data.features$id)
    data.features$id <- as.vector(data.features$id)
    
    if (!is.null(split.by)) {
        splits <- Seurat::FetchData(object, vars = split.by)[cells, split.by]
        if (split.colors) {
            if (length(unique(splits)) > length(cols)) stop(sprintf("Need at least %d colors in 'cols'", length(unique(splits))))
            cols <- cols[seq_along(unique(splits))]
            names(cols) <- unique(splits)
        }
        data.features$id <- paste(data.features$id, splits, sep = "_")
        us <- unique(splits)
        id.levels <- paste0(rep(id.levels, each = length(us)), "_", rep(us, times = length(id.levels)))
    }
    
    data.plot <- lapply(unique(data.features$id), function(ident) {
        df <- data.features[data.features$id == ident, 1:(ncol(data.features) - 1), drop = FALSE]
        avg.exp <- apply(df, 2, function(x) mean(expm1(x)))
        pct.exp <- apply(df, 2, Seurat:::PercentAbove, threshold = 0)
        list(avg.exp = avg.exp, pct.exp = pct.exp)
    })
    names(data.plot) <- unique(data.features$id)
    
    if (cluster.idents) {
        mat <- do.call(rbind, lapply(data.plot, unlist))
        mat <- scale(mat)
        id.levels <- id.levels[hclust(dist(mat))$order]
    }
    
    data.plot <- do.call(rbind, lapply(names(data.plot), function(x) {
        d <- as.data.frame(data.plot[[x]])
        d$features.plot <- rownames(d); d$id <- x; d
    }))
    if (!is.null(id.levels)) data.plot$id <- factor(data.plot$id, levels = id.levels)
    
    ngroup <- length(levels(data.plot$id))
    if (ngroup == 1) { scale <- FALSE; warning("Only one identity present; expression values will not be scaled", call. = FALSE, immediate. = TRUE) }
    else if (ngroup < 5 && scale) { warning("Scaling with few groups can be misleading", call. = FALSE, immediate. = TRUE) }
    
    # color-like variable (kept for fill mapping)
    avg.exp.scaled <- sapply(unique(data.plot$features.plot), function(x) {
        v <- data.plot[data.plot$features.plot == x, "avg.exp"]
        if (scale) Seurat:::MinMax(scale(log1p(v)), min = col.min, max = col.max) else log1p(v)
    })
    avg.exp.scaled <- as.vector(t(avg.exp.scaled))
    if (split.colors) avg.exp.scaled <- as.numeric(cut(avg.exp.scaled, breaks = 20))
    data.plot$avg.exp.scaled <- avg.exp.scaled
    
    # alpha driver: per-feature log1p → [0,1]
    avg.exp.alpha <- sapply(unique(data.plot$features.plot), function(x) {
        v <- data.plot[data.plot$features.plot == x, "avg.exp"]; v <- log1p(v); Seurat:::MinMax(v, min = 0, max = 1)
    })
    data.plot$alpha <- as.vector(t(avg.exp.alpha))
    
    data.plot$features.plot <- factor(data.plot$features.plot, levels = features)
    data.plot$pct.exp[data.plot$pct.exp < dot.min] <- NA
    data.plot$pct.exp <- data.plot$pct.exp * 100
    
    if (split.colors) {
        splits.use <- unlist(lapply(data.plot$id, function(x)
            sub(paste0(".*_(", paste(sort(unique(splits), decreasing = TRUE), collapse = "|"), ")$"), "\\1", x)))
        data.plot$colors <- mapply(function(color, value) colorRampPalette(c("grey", color))(20)[value],
                                   color = cols[splits.use], value = avg.exp.scaled)
    }
    
    fill.by <- if (split.colors) "colors" else "avg.exp.scaled"
    
    if (!is.na(scale.min)) data.plot[data.plot$pct.exp < scale.min, "pct.exp"] <- scale.min
    if (!is.na(scale.max)) data.plot[data.plot$pct.exp > scale.max, "pct.exp"] <- scale.max
    if (!is.null(feature.groups)) data.plot$feature.groups <- factor(feature.groups[data.plot$features.plot], levels = unique(feature.groups))
    
    library(ggplot2)
    plot <- ggplot(data.plot, aes(x = .data$features.plot, y = .data$id)) +
        geom_point(
            aes(size = .data$pct.exp,
                fill = .data[[fill.by]],
                alpha = .data$alpha),
            shape = point.shape, colour = "black", stroke = 0.25
        ) +
        scale.func(range = c(0, dot.scale), limits = c(scale.min, scale.max)) +
        scale_alpha(range = alpha.range, limits = c(0, 1)) +
        theme_minimal(base_size = 11) +
        theme(axis.title.x = element_blank(), axis.title.y = element_blank())
    
    if (!is.null(feature.groups)) {
        plot <- plot +
            facet_grid(~feature.groups, scales = "free_x", space = "free_x", switch = "y") +
            theme(panel.spacing = grid::unit(1, "lines"), strip.background = element_blank())
    }
    
    if (split.colors) {
        plot <- plot + scale_fill_identity()
    } else if (length(cols) == 1) {
        plot <- plot + scale_fill_distiller(palette = cols)
    } else if (length(cols) == 2) {
        plot <- plot + scale_fill_gradient(low = cols[1], high = cols[2])
    } else {
        plot <- plot + scale_fill_gradientn(colours = cols)
    }
    
    if (!split.colors) {
        plot <- plot +
            NoGrid()+
            guides(
                fill  = guide_colorbar(title = "Average Expression"),
                size  = guide_legend(title = "Percent Expressed"),
                alpha = if (show.alpha.legend) guide_legend(title = "Avg exp (α)") else "none"
            )
    }
    plot
}

MyDotPlot(
  so, features = top_genes, assay = "RNA",
  group.by = "annotation_level2",
  cols = colorRampPalette(c('white','orange'))(20),#rev(viridisLite::magma(10)),
  point.shape = 21, alpha.range = c(0.5, 1), show.alpha.legend = T
) +coord_flip()



```


**Limma with annotation level2**
~ 0 + annotation_level2 + IGT
```{r}
# prefix3 = "limma/20250323_level2_IGT"
prefix3 = "limma/20260107_level2_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(unique(mdata$igt_number))])  #unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))]
mdata$annotation_level2 =  factor(mdata$annotation_level2, levels = intersect(levels(mdata$annotation_level2), unique(mdata$annotation_level2))) #names(which(!table( mdata$annotation_level2)==0))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + annotation_level2 + IGT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("annotation_level2", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level2) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level2)) {
    print(cl)
    group1_filter <- metadata$annotation_level2 == cl #expr(annotation_level2 == cl)
    group2_filter <- metadata$annotation_level2 != cl #expr(!(annotation_level2 %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level2")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
# saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,30, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()

pdf(sprintf("%s/%s/%s/heatmap_filtered2.pdf", prefix, prefix2, prefix3), 20,10, useDingbats = F)
ann_cols_df = so_orig@meta.data %>% count(annotation_level2, annotation_level1, annotation_level2_group) 
ann_cols_df$n = NULL
ann_cols_df$annotation_level2 = NULL
rownames(ann_cols_df) = colnames(fit2$coefficients)
ann_palettes <- list(
  annotation_level1 = mypal_level1,
  annotation_level2_group = c(resting = "blue", activated = "red", other = "black", proliferating = "grey", miniverse = "white")
)

sub_col = !grepl("thymocyte", colnames(fit2$coefficients))
# sub = fit_flash$pve > 10^-4 | rowSums(abs(fit2$coefficients[,sub_col]) > 1) >= 1
sub = rowSums(abs(fit2$coefficients[,sub_col]) > 0.5) >= 1 | rownames(fit2$coefficients) == "F57"
ColorRamp = rev(colorRampPalette(brewer.pal(11, "PuOr"))(101))
pheatmap(fit2$coefficients[sub,sub_col], cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, main = "rowSums(abs(fit2$coefficients) > 0.5) > 1", annotation_col = ann_cols_df, annotation_colors = ann_palettes) #display_numbers = labels_matrix[sub,]
pheatmap(fit2$coefficients[sub,sub_col], cluster_rows = T, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, main = "rowSums(abs(fit2$coefficients) > 0.5) > 1", annotation_col = ann_cols_df, annotation_colors = ann_palettes) #display_numbers = labels_matrix[sub,]
dev.off()

#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))




#################
message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
# saveRDS(fit2, file = sprintf("%s/%s/fit_limma_level2_IGTHT_constrastfit.Rds", prefix, prefix2))
fit2 = readRDS(sprintf("%s/%s/fit_limma_level2_IGTHT_constrastfit.Rds", prefix, prefix2))
# Extract p-values for all comparisons
adj_pvalues = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH")
# write.table(results, file = sprintf("%s/%s/fit_limma_leve2_IGTHT_table.txt", prefix, prefix2), quote = F, row.names = T, col.names = T, sep = ",")

pvmat = adj_pvalues
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/fit_limma_level2_IGTHT_heatmap.pdf", prefix, prefix2), 20,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


```

do ~ 0 + annotation_level2 + IGTHT ?

**Limma with organ in healthy**
~ 0 + organ_simplified + IGT

```{r}
prefix3 = "limma/20250324_organsimplified_IGT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig %>% filter(condition_broad == "healthy") %>% as.data.frame()
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

mdata$organ_simplified = make.names(mdata$organ_simplified)
mdata$organ_simplified =  factor(mdata$organ_simplified, levels = names(which(!table( mdata$organ_simplified)==0)))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + organ_simplified + IGT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("organ_simplified", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(organ_simplified) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$organ_simplified)) {
    print(cl)
    group1_filter <- expr(organ_simplified == cl)
    group2_filter <- expr(!(organ_simplified %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "organ_simplified")
    nmecontrast = sprintf("%s_vs_AllinHealthy", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
# fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,20, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))


```

**Topics in CD4**

Th1 topics
26: Ifng, ccl5 etc
X10

Th2 topics
56: IL4, il13
159: Il1rl1 gata3 areg
25

Th17 topics
152: Treg_cl8 (Maf, Il10, Ctla4)
161: Il17a (PD1, Nr4a1)
72: IL22, Bhlh240, Odc1
36

```{r}
so = so_orig[,so_orig$annotation_level1 == "CD4" & !so_orig$annotation_level2 %in% c("CD4_miniverse", "CD4_prolif")]
L1 = with(ldf(fit, type = "i"), L) #same as res$F %*% diag(res$D)

cd4_l1 = data.frame(so@meta.data,L1[colnames(so),])
cd4_l1 = cd4_l1 %>% mutate(th1 = X10+X25+X26,th2 = X56+X159+X25, th17 = X161+X72+X36+X13)
cd4_l1 = cd4_l1 %>% mutate(th1 = X26+X10,th2 = X56, th17 = X161)


# p = ggplot(cd4_l1) + geom_scattermore(aes(X10, X159, color = annotation_level2), pointsize = 1, alpha = 1, pixels = c(512,512)) + scale_color_manual(values = mypal_level2) + ggtitle("") + theme_minimal() + NoLegend()
# p

# p = ggplot(cd4_l1 %>% filter(annotation_level2_group %in% c("activated") )) + geom_point(aes(X10, X159, color = annotation_level2), size = 0.1,alpha = 0.5) + xlim(c(0,0.0025)) + scale_color_manual(values = mypal_level2) + ggtitle("") + theme_minimal() + NoLegend()
# p + facet_wrap(~annotation_level2)

# pdf(sprintf("%s/%s/CD4_th_topics_scatter.pdf", prefix, prefix2), 6, 6, useDingbats = F)
pdf(sprintf("%s/%s/CD4_th_topics_scatter_split.pdf", prefix, prefix2), 20, 20, useDingbats = F)
p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th1 + 0.01), log(th2 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    xlim(c(min(log(cd4_l1$th1+0.01)),-2)) +
    ggtitle("") + 
    theme_minimal() 
# p 
# p + NoLegend()
p+facet_wrap(~annotation_level2)

p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th1 + 0.01), log(th17 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    xlim(c(min(log(cd4_l1$th1+0.01)),-2)) +
    ggtitle("") + 
    theme_minimal() + 
    NoLegend()
# p
p+facet_wrap(~annotation_level2)


p = ggplot(cd4_l1) + 
    geom_jitter(aes(log(th17 + 0.01), log(th2 + 0.01), color = annotation_level2), 
                size = 0.5, alpha = 0.5, width = 0.1, height = 0.1) +  # Add jitter with specified width and height
    scale_color_manual(values = mypal_level2) + 
    ggtitle("") + 
    theme_minimal() + 
    NoLegend()
# p
p+facet_wrap(~annotation_level2)
dev.off()


pdf(sprintf("%s/%s/CD4_th_topics_violin.pdf", prefix, prefix2), 10, 7, useDingbats = F)
p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th17 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th17 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p

p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th1 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th1 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p

p = ggplot(cd4_l1) + 
  geom_violin(aes(x = annotation_level2, y = log(th2 + 0.01), fill = annotation_level2), 
              alpha = 0.5, trim = TRUE) +  # Violin plot with filling and transparency
  geom_jitter(aes(x = annotation_level2, y = log(th2 + 0.01), color = annotation_level2), 
              size = 1, alpha = 0.5, width = 0.1, height = 0.1) +  # Scatter plot with jitter
  scale_color_manual(values = mypal_level2) +  # Color scale for points
  scale_fill_manual(values = mypal_level2) +  # Color scale for violins
  ggtitle("") + 
  theme_minimal() + 
  NoLegend()  # Remove legend
p
dev.off()




```

Gene tile plot
```{r}
F1 = with(ldf(fit, type = "i"), F)
colnames(F1) = paste("F", 1:ncol(F1), sep = "")
top_genes = apply(F1, 2, order, decreasing = TRUE)[1:10, c("F26","F56","F161")]
top_genes = unique(c("Ifng",rownames(fit$F_pm)[top_genes]))
top_genes


plot_data = melt(F1[top_genes,c("F26","F56","F161")], varnames = c("Gene", "Factor"), value.name = "Expression")

# Create the dot plot

pdf(sprintf("%s/%s/CD4_genematrix_topicsTh1217.pdf", prefix, prefix2), 3, 7, useDingbats = F)
p = ggplot(plot_data, aes(x = Factor, y = Gene, fill = Expression, alpha = Expression)) +
  geom_tile(width = 0.9, height = 0.9) +  # Adjust the width and height for the gaps
  scale_fill_gradient(low = "white", high = "brown") +  # Adjust color gradient
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    panel.grid = element_blank(),  # Remove gridlines
    panel.border = element_blank()  # Optional: remove the border around the plot
  ) +
    scale_y_discrete(limits = rev(levels(plot_data$Gene))) + 
  coord_fixed(ratio = 1) +  # Ensure tiles are square
  labs(title = "Dot Plot (Squares) of Gene Expression", x = "Layer", y = "Gene")
print(p)
dev.off()
```

Are all topic orthogonal?
```{r}

```

**Treg topic**




################

lm with organ in healthy: ~ 0 + organ_simplified + IGT + annotation_level1

```{r}
prefix3 = "limma/20250218_organsimplified_IGT_level1"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig %>% filter(condition_broad == "healthy") %>% as.data.frame()
mdata$IGT = factor(mdata$IGT, levels = unique(mdata$IGT)[order(extract_numeric(unique(mdata$IGT)))])

mdata$organ_simplified = make.names(mdata$organ_simplified)
mdata$organ_simplified =  factor(mdata$organ_simplified, levels = names(which(!table( mdata$organ_simplified)==0)))
# mdata$annotation_level2 = factor(mdata$annotation_level2)

mdata$annotation_level1 = factor(mdata$annotation_level1)

# Create the design matrix for the linear model
design = model.matrix(~ 0 + organ_simplified + IGT + annotation_level1, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("organ_simplified|annotation_level1", "", colnames(design))
colnames(design) = gsub("IGTIGT", "IGT", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(organ_simplified) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$organ_simplified)) {
    print(cl)
    group1_filter <- expr(organ_simplified == cl)
    group2_filter <- expr(!(organ_simplified %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "organ_simplified")
    nmecontrast = sprintf("%s_vs_AllinHealthy", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
# saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
# write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 20,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


#Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 & 
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))

```

lm with sample: 0 + IGTHT --> What samples are enriched in each GP? to find the samples for the low PVE topics

```{r}
prefix3 = "limma/20250218_IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))

# Create the design matrix for the linear model
design = model.matrix(~ 0  + IGTHT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
# saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(IGTHT) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$IGTHT)) {
    print(cl)
    group1_filter <- expr(IGTHT == cl)
    group2_filter <- expr(!(IGTHT %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "IGTHT")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 60,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


# Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 &
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))



```

lm with level2_IGTHT: 0 + annotation_level2_IGTHT --> Error in qr.default(x) : too large a matrix for LINPACK
lm with level1_IGTHT: 0 + annotation_level2_IGTHT --> Error in qr.default(x) --> What level 2 in each samples is enriched in each GP? to find the samples for the low PVE topics

```{r}
prefix3 = "limma/20250219_level1IGTHT"
ensure_directory(sprintf("%s/%s/%s", prefix, prefix2, prefix3))

mdata = mdata_orig
mdata$IGTHT = factor(mdata$IGTHT, levels = unique(mdata$IGTHT))
mdata$annotation_level1 =  factor(mdata$annotation_level1, levels = names(which(!table( mdata$annotation_level1)==0)))
mdata$annotation_level1_IGTHT = factor(paste(mdata$annotation_level1,mdata$IGTHT,sep = "_"))

# Create the design matrix for the linear model
design = model.matrix(~ 0  + annotation_level1_IGTHT, data = mdata) #make sure no empty category! otherwise creates an error during fit
colnames(design) = gsub("annotation_level1_IGTHT", "", colnames(design))
# Select the columns that match "^F" in mdata (assuming these are numeric variables)
feature_data = t(mdata[, grepl("^F", colnames(mdata))])
# Fit the linear model using limma
fit = lmFit(feature_data, design)
saveRDS(fit, file = sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))
# fit = readRDS(sprintf("%s/%s/%s/fit.Rds", prefix, prefix2, prefix3))

#subset the metadata depending on the design above and wanted contrast, i.e. remove the confounding
# metadata = mdata %>% select(annotation_level2, IGTHT) %>% unique() (IGTT is the confounding)
metadata = mdata %>% select(annotation_level1_IGTHT) %>% unique()
rownames(metadata) = NULL
contrasts = c()
namescontrasts = c()
for (cl in levels(metadata$annotation_level1_IGTHT)) {
    print(cl)
    group1_filter <- expr(annotation_level1_IGTHT == cl)
    group2_filter <- expr(!(annotation_level1_IGTHT %in% cl))
    groups = GetGroups(metadata, group1_filter,group2_filter, "annotation_level1_IGTHT")
    nmecontrast = sprintf("%s_vs_All", cl)
    # nmecontrast = CreateComparisonName(group1_filter, group2_filter)
    
    # contrasts = c()
    # namescontrasts = c()
    # # i = 1
    group1 = groups[[1]]
    group2 = groups[[2]]
    contrasts[cl] = sprintf("(%s)/%s-(%s)/%s", paste(group1, collapse = "+"), length(group1), paste(group2, collapse = "+"), length(group2))
    namescontrasts[cl] = nmecontrast
    # names(contrasts) = namescontrasts
    # gene_symbol = rownames(tmm$E)#rownames(so[["RNA"]]$counts)
}

message("contrasts.fit...")
cont.matrix = makeContrasts( contrasts = contrasts, levels = design)
colnames(cont.matrix) = namescontrasts
# colnames(cont.matrix) = names(contrasts)
fit2 = contrasts.fit(fit, cont.matrix)
message("eBayes...")
fit2 = eBayes(fit2, trend = TRUE, robust = TRUE)
saveRDS(fit2, sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))
fit2 = readRDS(sprintf("%s/%s/%s/fit_contrast.Rds", prefix, prefix2, prefix3))

#write coefficients
results = topTable(fit2, number = Inf, sort.by = "none", adjust.method = "BH") #same as fit2$coefficients
write.table(results, file = sprintf("%s/%s/%s/coefficients.csv", prefix, prefix2, prefix3), quote = F, row.names = T, col.names = T, sep = ",")

#Heatmap
# Extract p-values for all comparisons
pvmat = apply(fit2$p.value, 1, function(x) p.adjust(x, method = "BH"))
pvmat[is.na(pvmat)] = 1
pvmat = t(pvmat)
# extract_numeric(rownames(pvmat)) == extract_numeric(rownames(factor_means))
# extract_numeric(colnames(pvmat)) == extract_numeric(colnames(factor_means))
labels_matrix = pvmat
labels_matrix[pvmat<0.05] = "*"
labels_matrix[pvmat>0.05] = ""

pdf(sprintf("%s/%s/%s/heatmap.pdf", prefix, prefix2, prefix3), 60,10, useDingbats = F)
pheatmap(fit2$coefficients, cluster_rows = F, cluster_cols = F, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
pheatmap(fit2$coefficients, cluster_rows = T, cluster_cols = T, breaks = seq(-1,1,length.out = length(ColorRamp)+1), col = ColorRamp, display_numbers = labels_matrix, main = "fit2$coefficients")
dev.off()


# Write Tables and Volcanos
tt_list = list()
for (i in colnames(fit2$contrasts)) { #colnames(cont.matrix)
    print(i)
    tt_list[[i]] = topTable(fit2,coef = i ,n = Inf, adjust.method = "BH", sort.by = "none")
    tt_list[[i]]$SYMBOL = rownames(tt_list[[i]])
    # tt_list[[i]]$SYMBOL = gene_symbol
}

tmp = tt_list
names(tmp)

saveRDS(tt_list, file = sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))
message("Results saved to: ", sprintf("%s/%s/%s/ttlist.Rds", prefix, prefix2, prefix3))

pdf(sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3), width = 10, height = 10)
for (i in 1:length(tmp)) {
    print(i)
    vplot = na.omit(data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value + 10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))) #dealing with NA
    # vplot = data.frame(SYMBOL = tmp[[i]]$SYMBOL, fc = 2^tmp[[i]]$logFC, pval = tmp[[i]]$P.Value+10^-300, AveExpr = 2^(tmp[[i]]$AveExpr))
    p = Vplot(vplot = vplot, xlab = names(tmp)[i], xlimits = c(min(vplot$fc[vplot$fc != 0]), max(vplot$fc)), ylimits = c(min(vplot$pval), 1)) #c(min(vplot$pval[vplot$pval != 0]),1)
    sub = vplot %>%
        filter(pval < 0.05) %>% #abs(log2(fc)) > 0.5 &
        arrange(desc(log2(fc))) %>%
        pull(SYMBOL)
    highlight_genes = unique(c(head(sub, 25), tail(sub, 25)))
    # sub = (log2(vplot$fc) > 0.5 | log2(vplot$fc) < -0.5)  & vplot$pval < 0.05
    # sub = vplot[sub,] %>% arrange(desc(log2(fc)))
    # sub1 = sub %>% pull(SYMBOL) %>% head(25) #vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:200]
    # sub2 = sub %>% pull(SYMBOL) %>% tail(25)
    highlight_filter = vplot$SYMBOL %in% highlight_genes
    # sub = vplot$SYMBOL %in% c(sub1, sub2)#as.character(sub2$SYMBOL)[1:50]
    library(ggrepel)
    print(p + geom_text_repel(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
    # print(p + geom_text(data = vplot[highlight_filter,], aes(x = fc, y = pval, label = SYMBOL)))
}
dev.off()
message("Plots saved to: ", sprintf("%s/%s/%s/DiffExpression_volcanos.pdf", prefix, prefix2, prefix3))

if (length(tt_list) > 1) {
    tt = CollapseDiff_limmatrend(tt_list)
} else {
    tt = tt_list[[1]]
}
tt$SYMBOL = rownames(tt)
colnames(tt) = gsub(pattern = "AveExpr", replacement = "log2AveExpr", colnames(tt))
colnames(tt) = gsub(pattern = "logFC", replacement = "log2FC", colnames(tt))
tt = data.frame(SYMBOL = tt$SYMBOL, tt[,!colnames(tt) %in% "SYMBOL"])
write.table(x = tt, file = sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3), sep = "\t", quote = F)
message("Table saved to: ", sprintf("%s/%s/%s/ttlist.txt", prefix, prefix2, prefix3))



```


structure_plot.pdf
ebmfUMAP.pdf: new UMAP from fit$L (row normalized in module_scores_percentile2 for less batch effect)
ebmfUMAP_topics.pdf

```{r}
topic_colors = mypal[1:ncol(fit$L_pm)]#c("skyblue","forestgreen","darkmagenta","dodgerblue","gold","darkorange")

message("calculate topic_scores_percentile = row normalized L matrix")
#calculate module_scores_percentile for structure plot
res = ldf(fit, type = "i")
loadings = with(res, L %*% diag(D)  ) #same as res$L %*% diag(res$D)
#factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
#ldf = with(res, L %*% diag(D) %*% t(F) )
colnames(loadings) = sprintf("factor%s", 1:ncol(fit$L_pm))
#remove_topic = "factor2"
loadings = loadings[,!colnames(loadings) %in% remove_topic]
percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
module_scores_percentile = apply(loadings, 2, percentiles)
rownames(module_scores_percentile) = rownames(loadings)
module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
#colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))


pdf(sprintf("%s/%s/structure_plot_module_scores_percentile.pdf", prefix, prefix2), 20,8, useDingbats = F)
structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25,grouping = so$organ_simplified)
#structure_plot(module_scores_percentile2/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25,grouping = so$is_spleen_healthy)
#structure_plot(fit,colors = topic_colors,topics = 1:ncol(fit$L),gap = 25,grouping = so$is_spleen_healthy_igt)
#fit_spleenctrl = SubsetFit(fit, names(which(so$is_spleen_healthy == T)))
structure_plot(module_scores_percentile2[names(which(so$is_spleen_healthy)),]/100,colors = topic_colors,topics = 1:ncol(module_scores_percentile2),gap = 25, grouping = so$IGT[so$is_spleen_healthy == T])
dev.off()

pdf(sprintf("%s/%s/UMAP_module_scores_percentile.pdf", prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[,1], dim2 = so[["umap_totalvi"]]@cell.embeddings[,2], size = module_scores_percentile2[,k]) #fit$L_pm[,k] #match(colnames(so),rownames(so[["umap_totalvi"]]))
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

pdf(sprintf("%s/%s/UMAP_factors.pdf", prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(loadings) ) {
    print(k)
    #genes = module_genes %>% filter(Module == module) %>% pull(Gene)
    tmp = data.frame(so@meta.data, dim1 = so[["umap_totalvi"]]@cell.embeddings[,1], dim2 = so[["umap_totalvi"]]@cell.embeddings[,2], size = loadings[,k]) #fit$L_pm[,k] #match(colnames(so),rownames(so[["umap_totalvi"]]))
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()

#message("ebmfUMAP.csv") #New UMAP from fit$L (module_scores_percentile)
prefix_topic = sprintf("%s_%s",prefix,prefix2)
#so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = res , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = module_scores_percentile2 , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so = RunUMAP(so, dims = 1:ncol(module_scores_percentile2), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile.csv",prefix, prefix2), quote = F, row.names = TRUE, col.names = TRUE)

# tmp = read.csv(sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), header = T, row.names = 1)
# so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

# ldfl = ldf(fit,type = "i")$L
# so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = ldfl , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
# so = RunUMAP(so, dims = 1:ncol(ldfl), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))

umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile.pdf",prefix, prefix2), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

pdf(sprintf("%s/%s/ebmfUMAP_frommodule_scores_percentile_withmodules.pdf",prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(module_scores_percentile2) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = module_scores_percentile2[,k]) #fit$L_pm[,k] 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Topic %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()


prefix_topic = sprintf("%s_%s",prefix,prefix2)
so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = loadings , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
so = RunUMAP(so, dims = 1:ncol(loadings), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))
write.csv(so[[sprintf("umap_%s",prefix_topic)]]@cell.embeddings, file = sprintf("%s/%s/ebmfUMAP_fomLD.csv",prefix, prefix2), quote = F, row.names = TRUE, col.names = TRUE)

# tmp = read.csv(sprintf("%s/%s/ebmfUMAP.csv",prefix, prefix2), header = T, row.names = 1)
# so[[sprintf("umap_%s",prefix_topic)]] = CreateDimReducObject(embeddings = as.matrix(tmp), key = sprintf("%s_",prefix_topic), assay = "RNA")

# ldfl = ldf(fit,type = "i")$L
# so[[sprintf("%s",prefix_topic)]] = CreateDimReducObject(embeddings = ldfl , key = sprintf("%s_",prefix_topic), assay = "RNA") #fit$L_pm
# so = RunUMAP(so, dims = 1:ncol(ldfl), reduction = sprintf("%s",prefix_topic), n.components = 2, reduction.name = sprintf("umap_%s",prefix_topic))

message("ebmfUMAP.pdf")
umap_to_plot = sprintf("umap_%s",prefix_topic)
pdf(sprintf("%s/%s/ebmfUMAP_fromLD.pdf",prefix, prefix2), 20, 20, useDingbats = F)
MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "IGT", 
        split_by1 = "is_spleen_healthy",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()

MyPlots(seurat_object = so, 
        dim1 = so[[umap_to_plot]]@cell.embeddings[,1], 
        dim2 = so[[umap_to_plot]]@cell.embeddings[,2], 
        color_by = "organ_simplified", 
        split_by1 = "organ_simplified",
        split_by2 =  NULL, 
        genes = NULL, 
        cluster_key = NULL, mypal = mypal) #glasbey()
dev.off()

message("ebmfUMAP_topics.pdf")
pdf(sprintf("%s/%s/ebmfUMAP_fromLD_withfactors.pdf",prefix, prefix2), 9,8, useDingbats = F)
for (k in 1:ncol(loadings) ) {
    print(k)
    tmp = data.frame(so@meta.data, dim1 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),1], dim2 = so[[umap_to_plot]]@cell.embeddings[match(colnames(so),rownames(so[[umap_to_plot]])),2], size = loadings[,k]) #fit$L_pm[,k] 
    #tmp$size[tmp$size > 1] = 1
    #tmp$size[tmp$size < -1] = -1
    
    p = ggplot(tmp) + geom_point(aes(dim1, dim2, color = size), size = 2) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + scale_color_gradientn(colours = ColorRamp)+ theme(axis.text.x  = element_text(size=15), axis.text.y  = element_text(size=15), legend.text=element_text(size=15), axis.title.x = element_text(size=20) , axis.title.y = element_text(size=20), legend.title = element_blank()) + #alpha = 0.5
        ggtitle(label = sprintf("Factor %s",k)) #ggtitle(label = sprintf("%s:%s...",module, paste(genes[1:10], collapse=",")))
    print(p)
}
dev.off()



# ##########If needed: structure_plot equivalent
# percentiles = function(vector = c(1) ) {return(ecdf(vector)(vector) * 100) }
# module_scores_percentile = apply(fit$L_pm, 2, percentiles)
# rownames(module_scores_percentile) = rownames(fit$L_pm)
# module_scores_percentile2 = module_scores_percentile / rowSums(module_scores_percentile) *100
# colnames(module_scores_percentile2) = sprintf("topic%s", 1:ncol(fit$L_pm))
# 
# #single cell UMAP_1D order
# so = RunUMAP(so, dims = 1:30, reduction = "totalvi", n.components = 1, reduction.name = "totalvi_1d")
# all(rownames(so[["totalvi_1d"]]) == rownames(fit$L_pm))
# ord_cells = order(so[["totalvi_1d"]]@cell.embeddings[,1])
# 
# #order the modules
# hc = hclust(dist(t(module_scores_percentile2)))
# ord_modules = hc$order 
# ord_modules = colnames(module_scores_percentile2)[hc$order]
# 
# #pca = prcomp(module_scores_percentile2, scale. = TRUE)
# #pca_1 = pca$x[, 1]
# #ordered_df = as.data.frame(module_scores_percentile2[order(pca_1),])
# ordered_df = as.data.frame(module_scores_percentile2[ord_cells,ord_modules])
# ordered_df$cell_id = factor(rownames(ordered_df), ordered = T)
# melted_df = melt(ordered_df)
# melted_df$variable = factor(melted_df$variable, levels = ord_modules, ordered = T)
# melted_df = melted_df %>% arrange(cell_id)
# 
# pdf(sprintf("%s/%s/structure_plot.pdf", prefix, prefix2), 20,10, useDingbats = F)
# p = ggplot(melted_df, aes(x = cell_id, y = value, fill = variable)) +
#     geom_bar(stat = "identity") +
#     scale_fill_manual(values = mypal)+
#     labs(x = "Cells", y = "Score", fill = "Module") +
#     theme_minimal() +
#     theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#           panel.grid.major = element_blank(), 
#           panel.grid.minor = element_blank(),
#           panel.background = element_blank()
#     )
# print(p)
# dev.off()


```

*GSEA analysis on Treg sig**
--> GSEA_signatures.Rda
```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

message("Loading signatures")
load("/project/zemmour/david/signatures/mouse/signaturelist20171024.Rda")
signaturelist1 = signaturelist

load("/project/zemmour/david/signatures/mouse/signaturelistGSEA.Rda")
signaturelist2 = signaturelist

signaturelist = c(signaturelist1, signaturelist2)
names(signaturelist)

signaturelist = signaturelist[grepl("Treg|treg|TREG|TCELL", names(signaturelist))]
#names(signaturelist)[grepl("Treg|treg|Foxp3", names(signaturelist))]
#names(signaturelist)[grepl("IPEX", names(signaturelist))]

message("Calculating GSEA enrichement of Kait topic genes in each of David's factors")
pvalsig = list()
pvalcol = list()
fgseaRes_list = list()
for (f in 1:ncol(factors)) {
    print(f)
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = factors[,f], pval = exp(mean_shifted_log_counts))
    ranks = vplot$fc
    names(ranks) = vplot$SYMBOL
    fgseaRes = fgseaMultilevel(signaturelist, ranks, scoreType = "pos", minSize = 5)
    fgseaRes_list[[as.character(f)]] = fgseaRes
    pvalsig[[as.character(f)]] = fgseaRes$pval
    pvalcol[[as.character(f)]] = fgseaRes$NES
    #head(fgseaRes[order(padj, -abs(NES)), ], n=10)
    #plotEnrichment(signaturelist[["kait_topic_14"]], ranks)
}
#saveRDS(fgseaRes_list,file = sprintf("%s/%s/GSEA_signatures.Rda",prefix, prefix2))
fgseaRes_list = readRDS(sprintf("%s/%s/GSEA_signatures.Rda",prefix, prefix2))
names(fgseaRes_list) = colnames(factors)
fgseaRes_melt = fgseaRes_list
for (i in names(fgseaRes_melt)) {
    fgseaRes_melt[[i]][,"factor"] = i
}
fgseaRes_melt = do.call(rbind, fgseaRes_melt)

pdf(sprintf("%s/%s/GSEA_volcano_by_factor.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:ncol(factors)) {
    print(i)
    vplot = data.frame(SYMBOL = unlist(fgseaRes_list[[i]][,"pathway"]), fc = unlist(fgseaRes_list[[i]][,"NES"]), pval = unlist(fgseaRes_list[[i]][,"padj"]))
    p = Vplot(vplot = vplot, xlab = "", xlimits = c(1,2), ylimits = NULL) + ggtitle(names(fgseaRes_list)[i])
    #sub = vplot$pval < 0.05
    sub = vplot %>% filter(pval < 0.05) %>% arrange(desc(abs(log2(fc)))) %>% slice_head(n = 10) %>% rownames() #select(SYMBOL) %>% as.vector()
    #sub = vplot$SYMBOL %in% as.character(sub2$SYMBOL)[1:10]
    q = p + geom_text_repel(data = vplot[sub,], aes(x = fc, y = pval, label = SYMBOL, size = 1))
    print(q)
}
dev.off()


fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, padj, NES, size, factor) %>% slice_head(n = 2)
fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, factor, padj) %>% slice_head(n = 2) %>% as.data.frame()
fgseaRes_melt %>% group_by(factor) %>% filter(padj < 0.05) %>% arrange(padj, NES) %>% select(pathway, factor, padj) %>% as.data.frame()
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
colnames(pvalsig_df) = names(signaturelist)
rownames(pvalsig_df) = colnames(factors)
tmp = log10(pvalsig_df)
tmp[tmp > log10(0.05)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(100), main = "GSEA enrichement of Kait topic genes in each of David's factors")
dev.off()


```

*LD correlation with T cell activation?*

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

loadings = with(res, L %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(loadings) = sprintf("david.factor.%s", 1:ncol(loadings))
rownames(loadings) == colnames(so)

plot(so[["ADT"]]@counts["CD62L",], rowSums(loadings))
spl_cells
lm(so[["ADT"]]@counts["CD62L",] ~ rowSums(loadings))

rmcells = names(which(so[["ADT"]]@counts["CD44",] == 0))
so2 = so[,!colnames(so) %in% rmcells]
load_sum = rowSums(loadings)[!colnames(so) %in% rmcells]

DefaultAssay(so2) = "ADT"
#so = NormalizeData(so, assay = "ADT", normalization.method = "CLR")
so2 = NormalizeData(so2, assay = "ADT", normalization.method = "LogNormalize")
plot(so2[["ADT"]]@data["CD62L",], so2[["ADT"]]@data["CD44",])
pdf(sprintf("%s/%s/sumLxCD44_CD62L.pdf", prefix, prefix2), 10,10, useDingbats = F)
cr = cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so2[["ADT"]]@data["CD44",], load_sum, pch = 16, main = sprintf("cor = %s, p = %s", cr$estimate, cr$p.value))
cr = cor.test(so2[["ADT"]]@data["CD62L",], load_sum)
plot(so2[["ADT"]]@data["CD62L",], load_sum, pch = 16, main = sprintf("cor = %s, p = %s", cr$estimate, cr$p.value))
dev.off()

cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so2[["ADT"]]@data["CD44",], load_sum)
cor.test(so2[["ADT"]]@data["CD44",], load_sum)
plot(so[["ADT"]]@data["CD44",], rowSums(loadings))
plot(so[["ADT"]]@data["CD62L",spl_cells], rowSums(loadings)[spl_cells])
plot(so[["ADT"]]@data["CD44",spl_cells], rowSums(loadings)[spl_cells])

plot(so[["ADT"]]@data["CD62L",], 1.5^(rowSums(loadings)))
plot(so[["ADT"]]@data["CD62L",], 1.5^(rowSums(loadings)[]))
plot(so[["ADT"]]@data["CD62L",!colnames(so) %in% spl_cells], 1.5^(rowSums(loadings)[!colnames(so) %in% spl_cells]))

```

**DGE topic**
linear model with level2, organ_simplified, condition_detailed
1. Cosmology: Cell type-specific topics? Or combination of topics (Topic shared across cell type?)
Calculate for each level2 signature how much it is explained by a combination of topics? simple correlation?
2. Other topics that correlate with what? tissues? disease? Tissue-specific topics?

```{r}

```




**Compare topics with Kait's**
GSEA analysis works much better

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl"
fit = readRDS(sprintf("%s/%s/fit.Rds", prefix,prefix2))

kait_topics = read.table("/project/jfkfloor2/zemmourlab/david/immgent/analysis/integration/IGT1_56/Treg/topic_scrna_gene.csv", header = T, sep = ",")
kait_topics = kait_topics[kait_topics$gene %in% colnames(shifted_log_counts),]
kait_topics_list = kait_topics %>% group_by(topic) %>% group_split() %>% as.list() %>% lapply(.,as.data.frame)
names(kait_topics_list) = lapply(kait_topics_list, function(x) x[1,2]) %>% unlist() %>% gsub(.,pattern = "Topic_",replacement = "kait_topic_")
kait_topics_list = lapply(kait_topics_list, function(x) as.character(x[,1]))
signaturelist = kait_topics_list

message("Calculating Factor matrix")
res = ldf(fit, type = "i")
factors = with(res, F %*% diag(D)  ) #same as res$L %*% diag(res$D)
mean_shifted_log_counts = rowMeans(t(shifted_log_counts))
all(names(mean_shifted_log_counts) == rownames(factors))
colnames(factors) = sprintf("david.factor.%s", 1:ncol(factors))

message("Plot gene erichemtn  genechiSq enrichement of Kait topic genes in each of David's factors")
pdf(sprintf("%s/%s/KaitTopicGenes_inDavidFactors_heatmaps_FDR10p.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:length(kait_topics_list)) {
    print(i)
    factors_sub = factors[kait_topics_list[[i]],]
    
    # meta_col =  data.frame(pv = pvalsig_df[,names(kait_topics_list)[i]] < 0.05, stringsAsFactors = F)
    # meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    # rownames(meta_col) = colnames(tmp)
    
    meta_col =  data.frame(pv = tmp[,names(kait_topics_list)[i]] < 0, stringsAsFactors = F) #pvalsig_df[,names(kait_topics_list)[i]] < 0.05 & pvalcol_df[,names(kait_topics_list)[i]]
    meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    rownames(meta_col) = colnames(factors_sub)
    
    annotation_colors = list()
    annotation_colors[["pv"]] = c(signif = "red", notsignif = "grey")
    
    pheatmap(factors[kait_topics_list[[i]],], color = magma(10), cluster_cols = T, cluster_rows = T, annotation_col = meta_col, annotation_colors = annotation_colors, main = sprintf("%s genes in david's factors, value = increase in log1p by the factor", names(kait_topics_list)[i]))
}
dev.off()


message("Calculating GSEA enrichement of Kait topic genes in each of David's factors")
pvalsig = list()
pvalcol = list()
for (f in 1:ncol(factors)) {
    print(f)
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = factors[,f], pval = exp(mean_shifted_log_counts))
    ranks = vplot$fc
    names(ranks) = vplot$SYMBOL
    fgseaRes = fgseaMultilevel(signaturelist, ranks, scoreType = "pos")
    pvalsig[[as.character(f)]] = fgseaRes$pval
    pvalcol[[as.character(f)]] = fgseaRes$NES
    #head(fgseaRes[order(padj, -abs(NES)), ], n=10)
    #plotEnrichment(signaturelist[["kait_topic_14"]], ranks)
}
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
colnames(pvalsig_df) = names(signaturelist)
rownames(pvalsig_df) = colnames(factors)
tmp = log10(pvalsig_df)
tmp[tmp > log10(0.05)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(100), main = "GSEA enrichement of Kait topic genes in each of David's factors")
dev.off()

message("Plot gene erichemtn  genechiSq enrichement of Kait topic genes in each of David's factors")
pdf(sprintf("%s/%s/KaitTopicGenes_inDavidFactors_heatmaps_GSEA.pdf",prefix, prefix2), 10,10, useDingbats = F)
for (i in 1:length(kait_topics_list)) {
    print(i)
    factors_sub = factors[kait_topics_list[[i]],]
    
    # meta_col =  data.frame(pv = pvalsig_df[,names(kait_topics_list)[i]] < 0.05, stringsAsFactors = F)
    # meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    # rownames(meta_col) = colnames(tmp)
    
    meta_col =  data.frame(pv = tmp[,names(kait_topics_list)[i]] < 0, stringsAsFactors = F) #pvalsig_df[,names(kait_topics_list)[i]] < 0.05 & pvalcol_df[,names(kait_topics_list)[i]]
    meta_col$pv = factor(ifelse(meta_col$pv, yes = "signif", no = "notsignif"))
    rownames(meta_col) = colnames(factors_sub)
    
    annotation_colors = list()
    annotation_colors[["pv"]] = c(signif = "red", notsignif = "grey")
    
    pheatmap(factors[kait_topics_list[[i]],], color = magma(100), cluster_cols = T, cluster_rows = T, annotation_col = meta_col, annotation_colors = annotation_colors, main = sprintf("%s genes in david's factors, value = increase in log1p by the factor", names(kait_topics_list)[i]))
}
dev.off()

#Not as good but works:
message("Calculating chiSq enrichement of Kait topic genes in each of David's factors")
# pvalsig = matrix(nrow = ncol(factors), ncol = length(signaturelist) )
# pvalcol = matrix(nrow = ncol(factors), ncol = length(signaturelist) )
pvalsig = list()
pvalcol = list()
for (f in 1:ncol(factors)) {
    vplot = data.frame(SYMBOL = names(mean_shifted_log_counts), fc = exp(factors[,f]), pval = exp(mean_shifted_log_counts))
    #p = Vplot(vplot = vplot, xlab = i, xlimits = NULL, ylimits = NULL)
    
    #Calculate p and q for signatures for factor f
    pvalsig[[as.character(f)]] = c()
    pvalcol[[as.character(f)]] = c()
    for (i in 1: length(signaturelist)) {
        if ((i %% 100) == 0) {print(i)}
        tryCatch({
            sig = names(signaturelist)[i]
            vplot[,sig] = vplot$SYMBOL %in% signaturelist[[i]]
            a = length(which(vplot$fc < 1))
            b = length(which(vplot$fc > 1))
            c = length(which(vplot$fc[vplot[,sig]] < 1))
            d = length(which(vplot$fc[vplot[,sig]] > 1))
            cont_table = rbind(total = c(round(a/(a+b)*(c+d)), round(b/(a+b)*(c+d))), geneset = c(c, d))
            colnames(cont_table) = c("FC<1", "FC>1")
            c = chisq.test(cont_table)
            #pvalsig[[as.character(f)]][sig] = data.frame(pval = c$p.value, is_up = cont_table[2,2] > cont_table[1,2]  )
            pvalsig[[as.character(f)]][sig] = c$p.value
            pvalcol[[as.character(f)]][sig] = cont_table[2,2] > cont_table[1,2]  
        }, error=function(e){})
    }
    
}
pvalcol_df = do.call(rbind, pvalcol)
pvalsig_df = do.call(rbind, pvalsig)
tmp = log10(pvalsig_df)
qs =  p.adjust(as.vector(pvalsig_df), method = "fdr")
qs = matrix(qs, nrow = nrow(pvalsig_df), ncol = ncol(pvalsig_df), byrow = F)
rownames(qs) = rownames(pvalsig_df)
colnames(qs) = colnames(pvalsig_df)
tmp = log10(qs)
tmp[tmp > log10(0.1)] = log10(1)
tmp[!pvalcol_df] = log10(1)
pdf(sprintf("%s/%s/KaitTopic_DavidFactorsEnrichement_heatmap_FDR10p.pdf",prefix, prefix2), 10,10, useDingbats = F)
pheatmap(t(tmp), color = magma(7), main = "ChiSq enrichement of Kait topic genes in each of David's factors")
dev.off()



```


(Which metadata is significantly enriched in a topic?)
https://willwerscheid.github.io/flashier/articles/flashier_closer_look.html#sampling-from-the-posterior
One of the list elements in the object returned by flash is a function that can sample from posterior distributions on loadings and factors. Take the backfit above as an example. To better understand which tissues are bound up with whole blood effects, we might like confidence intervals for the third factor. We construct 95% confidence intervals using 200 samples and then finding 2.5% and 97.5% quantiles as follows:
```{r}
# Set seed for reproducibility.
set.seed(1)
# Use returned sampler to sample from posterior.
samp = fit$sampler(nsamp = 200)
# Only keep factor 3.
factor_samp <- lapply(samp, function(x) x[[2]][, 10])
factor_samp[[1]]
# Normalize the loadings.
factor_samp <- sapply(factor_samp, function(x) x / max(abs(x)))
factor_samp[[1]]
# Get 95% confidence intervals.
factor_ci <- apply(factor_samp, 1, quantile, c(0.025, 0.975))

# Only keep factor 3.
factor_samp <- lapply(samp, function(x) x[[2]][, 10])
factor_samp[[1]]
# Normalize the loadings.
factor_samp <- sapply(factor_samp, function(x) x / max(abs(x)))
factor_samp[[1]]
# Get 95% confidence intervals.
factor_ci <- apply(factor_samp, 1, function(x) quantile(x, c(0.025, 0.975)))

plot(fit, 
     include_scree = F,
     include_pm = T,
     kset = 10,
     plot_type = "histogram",
     pm_which = "loadings", 
     pm_groups = so$organ_simplified,
     #bins = 20,
     pm_colors = mypal[1:length(unique(so$organ_simplified))]) +NoLegend() + geom_errorbar(aes(ymin = factor_ci[1, ], ymax = factor_ci[2, ]))

plot(fit, kset = 10, include_scree = FALSE) + geom_errorbar(aes(ymin = factor_ci[1, ], ymax = factor_ci[2, ]))
```

**Flashier second approach**
from Peter: The "second approach" we discussed is a two-stage approach: (1) use the subset of "spike-in" cells to first identify the batch effects, then (2) include these as factors in a flashier analysis of the full data. (To be safe, it may be better not to includ the spike-in cells in Step 2.) This second approach is a slightly more advanced usage of flashier and I'll put together a short script that illustrates how to do this.

example code
```{r}
library(flashier)
set.seed(1)
n <- 2000 #cells
m <- 4000 #genes
k <- 8

# Simulate the gene expression patterns: (i) baseline expression, (ii)
# three "batch effects", (iii) four "cell types". The first cell type
# will be used to estimate the two batch effects.
F <- matrix(0,m,k)
rownames(F) <- paste0("gene",1:m)
colnames(F) <- c("baseline","batch1","batch2","batch3",
                 "celltype1","celltype2","celltype3","celltype4")
F[,"baseline"] <- abs(rt(m,df = 4))
F[,"batch1"] <- rexp(m)
F[,"batch2"] <- rexp(m)
F[,"batch3"] <- rexp(m)
for (i in 1:4) {
  j <- which(runif(m) < 0.2)
  l <- paste0("celltype",i)
  F[j,l] <- rexp(length(j))
}

# Simulate the batch and cell-type memberships.
L <- matrix(0,n,k)
rownames(L) <- paste0("barcode",1:n)
colnames(L) <- c("baseline","batch1","batch2","batch3",
                 "celltype1","celltype2","celltype3","celltype4")
L[,"baseline"] <- runif(n)
batch <- factor(sample(3,n,replace = TRUE))
L[batch == 1,"batch1"] <- 1
L[batch == 2,"batch2"] <- 1
L[batch == 3,"batch3"] <- 1
celltype <- factor(sample(4,n,replace = TRUE))
for (i in 1:4)
  L[celltype == i,paste0("celltype",i)] <- 1

# Simulate the data matrix.
X <- tcrossprod(L,F) + rexp(n*m)
rownames(X) <- rownames(L)
colnames(X) <- rownames(F)

# Split the data into cell type 1 and the remaining cell types (cell
# types 2-4).
X1 <- X[celltype == 1,]
X2 <- X[celltype != 1,]

# Fit a flashier model to "spike-in" data (cell type 1). Note that in
# the flash_greedy call, it might be better to use ebnm_point_normal
# instead of ebnm_point_exponential.
fit1 <- flash(X1,ebnm_fn = ebnm_point_exponential,var_type = 0,S = 1/n, greedy_Kmax = 1)
fit1 <- flash_greedy(fit1, Kmax = 3, ebnm_point_exponential)
fit1 <- flash_backfit(fit1,extrapolate = FALSE,maxiter = 100)
posthoc_labels1 <- c("baseline","batch3","batch1","batch2")
colnames(fit1$F_pm) <- posthoc_labels1
colnames(fit1$L_pm) <- posthoc_labels1

# Some sanity checks.
print(round(cor(F,fit1$F_pm),digits = 3))
ks <- c("baseline","batch1","batch2","batch3")
print(round(cor(L[celltype == 1,ks],fit1$L_pm[,ks]),digits = 3))

# Fit a flashier model to the remaining data (cell types 2-4) in which
# the batch effects estimated from the "spike-in" data are
# incorporated into the model. This is a bit more complicated and
# involves several steps:
#
#   1. Add the "baseline" factor and set other parameters.
#      (flash)
#
#   2. Add factors for the 3 previously estimated batch effects.
#      (flash_factors_init)
#
#   3. Initialize 3 more factors to capture the cell types.
#      (flash_greedy)
#
#   4. Fix the batch effects. (flash_factors_fix)
#
#   5. Fit the free (non-fixed) parameters. (flash_backfit)
#
n    <- nrow(X2)
fit2 <- flash(X2,ebnm_point_exponential,var_type = 0,S = 1/n,greedy_Kmax = 1)
fit2 <- flash_factors_init(fit2,
                           list(matrix(0,n,3),fit1$F_pm[,-1]),
                           ebnm_point_exponential)
fit2 <- flash_greedy(fit2,Kmax = 3,ebnm_point_exponential)
fit2 <- flash_factors_fix(fit2,2:4,"factors")
fit2 <- flash_backfit(fit2,extrapolate = FALSE,maxiter = 200)
posthoc_labels2 <- c("baseline",
                     "batch3","batch1","batch2",
                     "celltype2","celltype4","celltype3")
colnames(fit2$F_pm) <- posthoc_labels2
colnames(fit2$L_pm) <- posthoc_labels2

# Some sanity checks.
print(round(cor(fit1$F_pm[,c("batch1","batch2","batch3")],
                fit2$F_pm[,c("batch1","batch2","batch3")]),
            digits = 3))
print(round(cor(F,fit2$F_pm),digits = 3))
ks <- c("baseline",
        "batch1","batch2","batch3",
        "celltype2","celltype3","celltype4")
print(round(cor(L[celltype != 1,ks],fit2$L_pm[,ks]),digits = 3))
pheatmap(round(cor(L[celltype != 1,ks],fit2$L_pm[,ks]),digits = 3))
```

```{r}
prefix = "flashier"
prefix2 = "20240718_knolim_pe_pl_BatchRemoved"
ensure_directory(sprintf("%s/%s",prefix,prefix2))

fit = readRDS("flashier/20240718_knolim_pe_pl/fit.Rds") #50 topics, 2 batch topics (topic 2 and 3)

#calculate LDF on spleen only


#1. Add the "baseline" factor and set other parameters.
fit2 = flash(shifted_log_counts, 
             greedy_Kmax = 1,
             ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace),
             var_type = 2, 
             S = s1,
             backfit = FALSE)

#2. Add batch factors
fit2 = flash_factors_init(fit2,
                           list(matrix(0,nrow(shifted_log_counts),2),fit$F_pm[,c(2,3)]),
                           ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace))

#3. Find other factors
fit2 = flash_greedy(fit2,Kmax = 48,ebnm_fn = c(ebnm_point_exponential, ebnm_point_laplace))

#4. Fix batch effect topics
fit2 = flash_factors_fix(fit2,2:3,"factors") #fix the batch effect topics

#5. Fit the free (non-fixed) parameters. (flash_backfit)
fit2 = flash_backfit(fit2,extrapolate = FALSE, maxiter = 200)

saveRDS(fit2, file = sprintf("%s/%s/fit.Rds", prefix,prefix2))

```

















